# AGENT.md

Reladen プロジェクトで作業するエージェント向けのガイドです。

## プロジェクト概要
- Next.js (App Router) + TypeScript + Tailwind + shadcn/ui をベースにした PWA。オフラインは IndexedDB(web)/Tauri(app.db)、オンラインは Supabase に tombstone（`deleted` / `updated_at`）で同期。
- ドメイン: 住民の会話や振り返りログを扱う。評価ロジックは `apps/web/lib/evaluation` に集約。
- LLM 利用: GPT 出力を評価に活用。重みは `public/config/conversation-weights.json` と `apps/web/lib/evaluation/weights.ts` で管理。

## ディレクトリと役割
- `apps/web/app`: 画面と API (`/api/sync` など)。
- `apps/web/lib`: DB / 同期 / 永続化のロジック。特に `lib/persist/persist-conversation.ts`。
- `packages/shared/types`: Zod + 型定義。API/DB の型をここに追加・更新。
- `public/manifest.json`, `sentry.*`: PWA と Sentry 設定。
- `apps/desktop`: Tauri アプリ。Rust 経由で `app.db` を扱う。

## よく使うコマンド (pnpm)
- 初期セットアップ: `pnpm install`
- Web 起動: `pnpm dev`
- Lint/format: `pnpm lint`（`next lint`） / Prettier 設定あり
- テスト: `pnpm test`（web フロントは vitest）
- DB: `pnpm db:push`（Drizzle→Supabase）、`pnpm seed` / `pnpm seed:min`
- Tauri: `pnpm tauri:dev` / `pnpm tauri:build`（Rust toolchain 必須）

## 実装時の注意
- Tombstone 同期: 全テーブルで `updated_at` と `deleted` を更新し、削除済みを失わせない。
- オフライン対応: IndexedDB/Tauri KV（`apps/web/lib/db/kv-*`）に合わせる。API 経由の同期は `useSync` と `/app/api/sync` を確認。
- 型とバリデーション: 追加/変更は Zod と型をセットで。`@/` は `apps/web`、`@repo/shared` は `packages/shared` を指す。
- 会話永続化: `persist-conversation.ts` 周辺は慎重に変更。危険な場合はフィーチャーフラグを検討。
- Secrets: `.env` は手元のみ。公開 URL にハードコードしない。

## 変更時の指針
- 仕様に迷ったら README・DB マイグレーションを確認し、UI は shadcn/ui + Tailwind のパターンに沿う。
- 大きな変更前に関連テーブルや API を確認し、`packages/shared/types` を更新して web/Tauri 双方で型を共有。

## コミュニケーション
- エージェント出力やコメントは、常に日本語で丁寧に。簡潔だが礼儀正しく。

# エンコーディングとシェル

## シェルの使用
- すべてのコマンドは PowerShell 7（pwsh）で実行すること。
- PowerShell 5.1 を使う場合は必ず確認する。
  例: "C:\\Program Files\\PowerShell\\7\\pwsh.exe" -NoProfile -Command "<COMMAND>"

## 禁止事項
- `>` `>>` によるリダイレクトは禁止（PowerShell 5.1 互換のため）。
- Node / bash / type / copy など、エンコードを壊す操作は禁止。

## 書き込み時のコマンド（UTF-8 必須）
- `Set-Content -Encoding utf8`
- `Out-File -Encoding utf8`
- `Add-Content -Encoding utf8`

# AI 作業時のガイドライン

初めに読み、最終出力は日本語で、丁寧かつ簡潔にまとめる。

## 開発の基本理念
- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する。
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る。
- 問題を見つけたら放置せず、必ず対処または明示的に記録する。
- ボーイスカウトルール：エラーを見つけた時よりも良い状態で残す。

## エラーハンドリングの原則
- 関連が薄く見えるエラーでも必ず解決する。
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正する。
- 早期にエラーを検出し、明確なエラーメッセージを提供する。
- エラーケースも必ずテストでカバーする。
- 外部APIやネットワーク通信は必ず失敗する可能性を考慮する。

## コード品質の基準
- DRY原則：重複を避け、単一の信頼できる情報源を維持する。
- 名前と関数で意図を表現し、可読性を優先。
- プロジェクト全体で一貫したコーディングスタイルを維持する。
- 乱暴な暫定実装は避け、未使用コードは残さない。
- 小さな問題も放置せず、発見次第修正する（Broken Windows理論）。
- コメントは「なぜ」を説明し、「何を」はコードで表現する。

## テスト
- テストは原則スキップしない。問題があれば修正する。
- 実装詳細ではなく振る舞いをテストする。
- テスト間の依存を避け、任意の順序で実行可能にする。
- テストは高速で、常に同じ結果を返すように意識する。
- カバレッジは指標であり、質の高いテストを重視する。

## リファクタとメンテ
- 機能追加と同時に既存コードの改善を検討する。
- 大規模な変更は小さなステップに分割する。
- 使われていないコードは削除する。
- 依存関係は定期的に更新する（セキュリティと互換性のため）。
- 技術的負債は明示的にコメントやドキュメントに記録する。

## セキュリティ
- API キーやパスワードは環境変数で管理（ハードコード禁止）。
- 機微情報のログ出力は禁止。
- 最小限の権限で処理する。
- 設計時に攻撃面を考慮し、必要なら対策を追加。
- 不要な依存関係を避ける。

## パフォーマンス
- 推測ではなく計測に基づいて最適化する。
- 初期段階から拡張性を考慮する。
- 重い処理は計測して優先度を判断。
- N+1 など明らかなボトルネックは排除。
- キャッシュやリソース管理は丁寧に設計。

## 運用とモニタリング
- タイムアウトや再試行を適切に設定。
- サーキットブレーカー/パターンが必要か検討。
- 一時的な障害に備え、可観測性を確保。
- 緊急停止やロールバック手段を意識。
- 適切なログとメトリクスで可観測性を確保する。

## プロジェクトコンテキスト
- ビジネス要件と技術要件のバランスを取る。
- 現在のフェーズで本当に必要な品質レベルを判断する。
- 時間制約がある場合でも、最低限の品質基準を維持する。

## トレードオフ
- すべてを完璧にすることは不可能（銀の弾丸は存在しない）である。
- 制約の中で最適なバランスを見つける。
- プロトタイプなら簡潔さを、本番なら堅牢性を優先する。
- 妥協点とその理由を明確にドキュメント化する。

## Git 運用
- コミットメッセージは `feat:`, `fix:`, `docs:`, `test:`, `refactor:`, `chore:` を基本に。
- コミットは小さく、一つの変更に集中。
- 明確で説明的なコミットメッセージを日本語で記述する。
- main/master への直接コミットは避ける。

## コードレビュー
- レビューコメントは建設的な改善提案として受け取る。
- 変更の意図と影響を明確にする。
- フィードバックは根拠を示して簡潔に。

## デバッグのベストプラクティス
- 再現手順を作る。
- 二分探索で原因範囲を絞る。
- 最近の変更をまず疑う。
- デバッガやプロファイラを積極的に使う。
- 調査結果と解決策を記録する。

## 依存管理
- 本当に必要な依存のみ追加する。
- package-lock.json 的なロックファイルは commit 必須。
- 新規依存はライセンス・サイズ・脆弱性を確認。
- セキュリティパッチは速やかに反映。

## ドキュメント
- README にプロジェクト概要・セットアップ・利用方法を明確に記載する。
- ドキュメントはコードと一緒に更新する。
- 実例を示すことを優先する。
- 重要な判断は ADR などで記録する。
