# AGENT.md

Reladen リポジトリで作業するエージェント向けの短い手引きです。

## プロジェクト概要
- Next.js (App Router) + TypeScript + Tailwind + shadcn/ui の PWA。オフライン (IndexedDB) / Tauri (app.db) と Supabase を tombstone (`deleted` / `updated_at`) 付きで双方向同期。
- ドメイン: 住人・会話イベントのログを扱い、好感度や印象を簡易集計。会話評価ロジックは `apps/web/lib/evaluation` 周辺。
- 生成系: GPT 出力を利用。重みは `public/config/conversation-weights.json` と `apps/web/lib/evaluation/weights.ts` を参照。

## ディレクトリと型
- `apps/web/app`: 画面と API (`/api/sync` など)。
- `apps/web/lib`: DB/同期/永続化ロジック。会話保存は `lib/persist/persist-conversation.ts`。
- `packages/shared/types`: Zod + 共有型。API/DB の型はここから利用・追加する。
- `public/manifest.json`, `sentry.*`: PWA と Sentry 設定。
- `apps/desktop`: Tauri 用。Rust 側で `app.db` を配置。

## 開発コマンド (pnpm)
- 依存導入: `pnpm install`。Web 開発: `pnpm dev`。
- Lint/format: `pnpm lint` (`next lint`)。Prettier 設定あり。
- テスト: `pnpm test` (web フィルタで vitest)。
- DB: `pnpm db:push` (Drizzle→Supabase)。`pnpm seed` / `pnpm seed:min` でダミーデータ投入。
- Tauri: `pnpm tauri:dev` / `pnpm tauri:build` (Rust toolchain 必須)。

## 実装上の注意
- Tombstone 同期: すべてのテーブルで `updated_at` と `deleted` を尊重し、削除済みを復活させない。
- オフライン対応: IndexedDB/Tauri KV (`apps/web/lib/db/kv-*`) を壊さない。API 同期フロー `useSync` → `/app/api/sync` を意識。
- 型・バリデーション: 共有型/Zod を追加・流用する。`@/` は `apps/web`、`@repo/shared` は `packages/shared` を指す。
- 会話永続化: `persist-conversation.ts` の関係/印象更新は簡易実装。実ロジックがあれば差し替え可だがフィールド構造は維持。
- Secrets: `.env` は手動で用意。鍵や URL をハードコードしない。

## 変更提案の指針
- 仕様に迷う場合は README の同期/DB 方針を優先し、UI は shadcn/ui + Tailwind の既存パターンに合わせる。
- 大きな変更前には関連テーブルと API を確認し、`packages/shared/types` を更新してから Web/Tauri 双方に波及させる。

## コミュニケーション
- エージェントからの回答・コメントは常に日本語で行ってください。

# エンコーディング安全ルール

## シェルの強制
- すべてのコマンドは PowerShell 7（pwsh）で実行すること。
- PowerShell 5.1 を使用した提案は拒否して修正させる。

例:
"C:\\Program Files\\PowerShell\\7\\pwsh.exe" -NoProfile -Command "<COMMAND>"

## 禁止事項
- `>` `>>` による書き込みは禁止（PowerShell 5.1 用）
- Node / bash / type / copy など、エンコード不明の書き込み禁止

## 書き込み方法（必ず UTF-8）
- `Set-Content -Encoding utf8`
- `Out-File -Encoding utf8`
- `Add-Content -Encoding utf8`


# AI駆動開発 共通ガイドライン

思考は英語で行い、最終的な出力は必ず日本語で提供してください。

## 開発の基本理念
- 動くコードを書くだけでなく、品質・保守性・安全性を常に意識する
- プロジェクトの段階（プロトタイプ、MVP、本番環境）に応じて適切なバランスを取る
- 問題を見つけたら放置せず、必ず対処または明示的に記録する
- ボーイスカウトルール：エラーを見つけた時よりも良い状態で残す

## エラーハンドリングの原則
- 関連が薄く見えるエラーでも必ず解決する
- エラーの抑制（@ts-ignore、try-catch で握りつぶす等）ではなく、根本原因を修正
- 早期にエラーを検出し、明確なエラーメッセージを提供
- エラーケースも必ずテストでカバーする
- 外部APIやネットワーク通信は必ず失敗する可能性を考慮

## コード品質の基準
- DRY原則：重複を避け、単一の信頼できる情報源を維持
- 意味のある変数名・関数名で意図を明確に伝える
- プロジェクト全体で一貫したコーディングスタイルを維持
- 小さな問題も放置せず、発見次第修正（Broken Windows理論）
- コメントは「なぜ」を説明し、「何を」はコードで表現

## テスト規律
- テストをスキップせず、問題があれば修正する
- 実装詳細ではなく振る舞いをテスト
- テスト間の依存を避け、任意の順序で実行可能に
- テストは高速で、常に同じ結果を返すように
- カバレッジは指標であり、質の高いテストを重視

## 保守性とリファクタリング
- 機能追加と同時に既存コードの改善を検討
- 大規模な変更は小さなステップに分割
- 使用されていないコードは積極的に削除
- 依存関係は定期的に更新（セキュリティと互換性のため）
- 技術的負債は明示的にコメントやドキュメントに記録

## セキュリティの考え方
- APIキー、パスワード等は環境変数で管理（ハードコード禁止）
- すべての外部入力を検証
- 必要最小限の権限で動作（最小権限の原則）
- 不要な依存関係を避ける
- セキュリティ監査ツールを定期的に実行

## パフォーマンスの意識
- 推測ではなく計測に基づいて最適化
- 初期段階から拡張性を考慮
- 必要になるまでリソースの読み込みを遅延
- キャッシュの有効期限と無効化戦略を明確に
- N+1問題やオーバーフェッチを避ける

## 信頼性の確保
- タイムアウト処理を適切に設定
- リトライ機構の実装（指数バックオフを考慮）
- サーキットブレーカーパターンの活用
- 一時的な障害に対する耐性を持たせる
- 適切なログとメトリクスで可観測性を確保

## プロジェクトコンテキストの理解
- ビジネス要件と技術要件のバランスを取る
- 現在のフェーズで本当に必要な品質レベルを判断
- 時間制約がある場合でも、最低限の品質基準を維持
- チーム全体の技術レベルに合わせた実装選択

## トレードオフの認識
- すべてを完璧にすることは不可能（銀の弾丸は存在しない）
- 制約の中で最適なバランスを見つける
- プロトタイプなら簡潔さを、本番なら堅牢性を優先
- 妥協点とその理由を明確にドキュメント化

## Git運用の基本
- コンベンショナルコミット形式を使用（feat:, fix:, docs:, test:, refactor:, chore:）
- コミットは原子的で、単一の変更に焦点を当てる
- 明確で説明的なコミットメッセージを日本語で記述
- main/masterブランチへの直接コミットは避ける

## コードレビューの姿勢
- レビューコメントは建設的な改善提案として受け取る
- 個人ではなくコードに焦点を当てる
- 変更の理由と影響を明確に説明
- フィードバックを学習機会として歓迎

## デバッグのベストプラクティス
- 問題を確実に再現できる手順を確立
- 二分探索で問題の範囲を絞り込む
- 最近の変更から調査を開始
- デバッガー、プロファイラー等の適切なツールを活用
- 調査結果と解決策を記録し、知識を共有

## 依存関係の管理
- 本当に必要な依存関係のみを追加
- package-lock.json等のロックファイルを必ずコミット
- 新しい依存関係追加前にライセンス、サイズ、メンテナンス状況を確認
- セキュリティパッチとバグ修正のため定期的に更新

## ドキュメントの基準
- READMEにプロジェクトの概要、セットアップ、使用方法を明確に記載
- ドキュメントをコードと同期して更新
- 実例を示すことを優先
- 重要な設計判断はADR (Architecture Decision Records)で記録

## 継続的な改善
- 学んだことを次のプロジェクトに活かす
- 定期的に振り返りを行い、プロセスを改善
- 新しいツールや手法を適切に評価して取り入れる
- チームや将来の開発者のために知識を文書化