# 2-3 主要技術

Reladen は、Web(PWA)・デスクトップ(Tauri)双方での動作と、Supabase/GPT-API を前提とした構成であり、  
以下の技術スタックを中核として採用する。

- フロントエンド: Next.js(App Router) + TypeScript + Tailwind CSS + shadcn/ui + Zod + Framer Motion (+ TanStack Query)
- バックエンド/データストア: Supabase(Postgres, Auth, Realtime) + Drizzle ORM
- クライアントローカル永続: IndexedDB（Web） / SQLite `app.db`（Tauri）
- PWA・デスクトップ基盤: next-pwa + Tauri(Rust)
- デプロイ・開発環境: Vercel + Node.js + pnpm (+ Rust toolchain)

## 2-3-1 フロントエンド技術

### Next.js (App Router) + React

- UI は Next.js の App Router 構成を用いた React アプリケーションとして実装する。
- 画面遷移・レイアウト・サーバーコンポーネント等は Next.js 標準の仕組みに従う。
- Web クライアント（ブラウザ/PWA）と Tauri クライアント（WebView 内）は、  
  **同一の Next.js アプリケーションを共有**する。

### TypeScript

- プロジェクト全体を TypeScript で実装し、型安全性を確保する。
- 型定義は以下のレイヤーで統一的に扱う。
  - ドメインモデル（住人・関係・印象・WorldFacts 等）
  - API 入出力（Next.js API Route, GPT 呼び出し）
  - Supabase / Drizzle スキーマから生成される型

### Tailwind CSS + shadcn/ui

- スタイルは **Tailwind CSS** をベースとし、ユーティリティクラスによるレイアウト・配色・レスポンシブ対応を行う。
- UI コンポーネントは **shadcn/ui** を採用し、共通の UI パターン（ボタン・ダイアログ・フォーム等）を提供する。
- Tailwind と shadcn/ui によるデザインガイドラインを共有することで、
  Web / デスクトップ双方で一貫した UI/UX を実現する。

### TanStack Query（データ取得・キャッシュ）

- Supabase 等からのデータ取得・キャッシュ・ローディング状態管理には **TanStack Query** を利用する。
- 特に以下の用途を想定する。
  - 住人一覧・関係・印象・WorldFacts 等のフェッチとキャッシュ
  - 再フェッチタイミングの制御（フォーカス/ネットワーク復帰時等）
  - ミューテーション（更新処理）の結果を UI に反映するためのキャッシュ更新

### Zod（バリデーション・型スキーマ）

- フォーム入力や API 応答のバリデーションには **Zod** を利用する。
- 主な用途:
  - ユーザー入力（住人作成・編集、設定変更等）の妥当性チェック
  - Next.js API Route で受け取るリクエストボディのスキーマ検証
  - GPT-API からの応答を、想定する構造に変換・検証する際の型ガード

### Framer Motion（アニメーション）

- 画面遷移・カード表示・ログの出現など、視覚的フィードバックのアニメーションには **Framer Motion** を利用する。
- 目的は以下の通り:
  - ログ更新／会話発生時の「動き」による状態変化の認知性向上
  - モーダルやダイアログの開閉時の自然なアニメーション
- アニメーションは演出の一部であり、**なくても機能要件は満たされる**ことを前提とする。

## 2-3-2 バックエンド・データストア

### Supabase（Postgres, Auth, Realtime）

- Supabase は以下の役割を担う。
  - Postgres による永続データストア（住人・関係・印象・会話・WorldFacts・TopicThreads 等）
  - 認証（Auth）および `owner_id` ベースの Row Level Security (RLS)
  - Realtime によるテーブル更新イベントの配信
- クライアントからの通常の CRUD は、**Supabase JS SDK / PostgREST** を中心に行う。
- Realtime 通知は、主に residents, relationships, impressions 等の主要テーブルおよび  
  相談・イベント通知用チャンネルで利用する（詳細は 2-2, セキュリティ章で定義）。

### Drizzle ORM（スキーマ・マイグレーション）

- Supabase(Postgres) に対する **型安全なスキーマ定義とマイグレーション管理**に Drizzle ORM を利用する。
- 主な用途:
  - `apps/web/lib/drizzle/schema.ts` 等でのテーブル定義
  - Drizzle の migration 機能（`drizzle-kit`, `pnpm db:push` 等）によるスキーマ更新
  - 一部サーバー処理（アカウント削除・データシード等）での型安全なクエリ実行
- 日常的な CRUD や同期処理は Supabase JS SDK を中心に実装し、  
  Drizzle は「スキーマ定義＋一部サーバー処理」に限定して利用する。

## 2-3-3 クライアントローカル永続

### Web クライアント: IndexedDB

- ブラウザ環境では、ローカルキャッシュおよびオフライン編集用の領域として **IndexedDB** を利用する。
- 主な用途:
  - Supabase から取得した住人・関係・印象・WorldFacts 等のキャッシュ
  - オフライン時の一時的な編集内容の保持
- IndexedDB へのアクセス方法（ラッパライブラリ等）は実装詳細とし、  
  仕様書では「IndexedDB をローカル DB として用いる」ことのみを定義する。

### デスクトップクライアント: SQLite (`app.db`)

- Tauri クライアントでは、ローカル DB として **SQLite ファイル `app.db`** を利用する。
- 主な用途:
  - Web クライアントと同様、Supabase データのキャッシュおよびオフライン編集の保持
  - Tauri 固有のメタ情報や設定の保存（必要に応じて）
- `app.db` へのアクセスには、Tauri の SQLite プラグイン等を用いる。
- 現時点では DB ファイルの暗号化は行わず、  
  **将来的に SQLCipher 等による暗号化導入を検討する項目**として扱う。

## 2-3-4 PWA・デスクトップ基盤

### PWA 対応（next-pwa）

- Web クライアントは、PWA としてインストール可能な形態を前提とする。
- 主な要素:
  - Web App Manifest（アイコン・名称・起動モード等）
  - Service Worker によるアセットキャッシュ・ルーティング制御
- これらの実装には **next-pwa** を利用する。
- OS レベルの Web Push 通知は、本仕様では必須要件とせず、  
  将来的な拡張候補として扱う。

### デスクトップアプリ（Tauri + Rust）

- デスクトップ版 Reladen は **Tauri** を用いて構築する。
  - WebView 部分で Next.js アプリを表示
  - Rust サイドでファイルアクセス・ローカル DB・通知 API 等のネイティブ機能を提供
- Tauri のビルドには Rust toolchain を必要とする。
  - Rust toolchain は「デスクトップアプリをビルドする開発者」にのみ必須であり、  
    Web クライアントのみを扱う開発者にとっては必須ではない。

## 2-3-5 デプロイ・開発環境

### デプロイ

- Next.js アプリケーションは **Vercel** にデプロイすることを前提とする。
  - Vercel 上で App Router / Edge Functions 等を利用可能。
  - Next.js の API Route を通じて GPT-API / Supabase へアクセスする構成を基本とする。
- Supabase プロジェクトは別途作成・管理し、  
  Vercel から環境変数経由で接続情報を注入する。

### 開発環境

- パッケージマネージャーとして **pnpm** を利用する。
  - スクリプト実行例: `pnpm dev`, `pnpm build`, `pnpm db:push` 等
- Node.js のバージョンは LTS 相当を前提とし、  
  具体的なバージョン要件は開発者向けドキュメント（README 等）で別途定義する。
- Lint / Format / Test などの品質ツール（ESLint, Prettier, テストフレームワーク等）は、  
  導入方針を今後検討し、必要に応じて別ドキュメントで管理する。
