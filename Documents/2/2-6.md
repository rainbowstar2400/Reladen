# 2-6 セキュリティ/RLS

Reladen は、Supabase の Row Level Security (RLS) を中心に据えたデータ保護と、  
HTTPS 通信・キー管理・削除ポリシー・ログ運用により、ユーザーごとの「世界」を分離して扱う。

本節では、主に以下の観点からセキュリティ方針を定義する。

- Supabase RLS（owner_id ベースのアクセス制御）
- 通信経路と各種キーの扱い
- データ削除ポリシー（tombstone / 物理削除）
- ログ／監視（Sentry 等）の扱い
- 開発／本番環境の分離方針

## 2-6-1 Supabase RLS とデータ所有

### owner_id と auth.uid()

- Supabase 上のユーザ識別子として **Supabase Auth のユーザ ID (`auth.uid()`)** を用いる。
- Reladen 内のアカウントと Supabase Auth のユーザーは 1 対 1 に対応するものとして扱う。
- 各レコードには `owner_id` カラムを持たせ、**そのレコードの所有者（＝世界の持ち主）**を表す。

### RLS 適用対象

- ユーザーごとの「世界」が完全に分離される設計とし、**ほぼすべての業務テーブルに RLS を適用**する。
  - 例：
    - 住人（residents）
    - 関係（relationships）
    - 印象（impressions）
    - 会話ログ（conversations 系）
    - 相談
    - WorldFacts
    - TopicThreads (`topic_threads`)
    - その他、ユーザー固有のデータを保持するテーブル
- 全ユーザー共通で参照されるマスタ情報のようなテーブルは現時点では想定せず、  
  「誰かの世界に属さない共有データ」は持たない前提とする。

### 基本ポリシー

- RLS は、各テーブルごとに以下のようなポリシーを前提とする。

  ```sql
  -- 例: owner_id ベースの RLS（概念レベル）
  create policy "select_own_rows"
    on some_table
    for select
    using (owner_id = auth.uid());

  create policy "insert_own_rows"
    on some_table
    for insert
    with check (owner_id = auth.uid());

  create policy "update_own_rows"
    on some_table
    for update
    using (owner_id = auth.uid())
    with check (owner_id = auth.uid());

  create policy "delete_own_rows"
    on some_table
    for delete
    using (owner_id = auth.uid());
````

* これにより、各ユーザーは **自分の `owner_id` に紐づく「世界」以外のレコードにはアクセスできない。**

### 世界共有機能の前提

* Reladen は現時点では「**1ユーザーが自分専用の世界を持つ**」ことを前提とし、
  複数ユーザーで同一 world を共有する機能は想定しない。
* 将来的に世界共有機能を導入する場合は、

  * `world_id` と `world_members` テーブル等を導入し、
  * RLS を `world_members` 経由の JOIN を含む形に拡張することを検討する。

## 2-6-2 通信経路とキー管理

### 通信

* Reladen は **HTTPS 通信を前提**とし、平文 HTTP は利用しない。
* Web / PWA / Tauri から Supabase / Vercel (Next.js API Route) / GPT-API への通信は、
  すべて TLS で保護された経路を使用する。

### Supabase キー

* クライアントからの通常アクセスには、`NEXT_PUBLIC_SUPABASE_URL` / `NEXT_PUBLIC_SUPABASE_ANON_KEY` を使用する。

  * これらは `NEXT_PUBLIC_` プレフィックス付きであり、クライアントバンドルに埋め込まれる。
  * したがって、**anon キー以外の機密情報は絶対に含めない。**
* `SUPABASE_SERVICE_ROLE_KEY` は高権限キーであり、以下のルールで扱う。

  * Next.js API Route や CLI スクリプトなど、**サーバーサイドのみで利用**する。
  * クライアントから参照されたり、`NEXT_PUBLIC_` 付きで公開されることはない。
  * 用途は以下のような限定された処理に絞る。

    * アカウント削除時の関連データ一括削除
    * メンテナンス用の管理スクリプト

### GPT / OpenAI API キー

* `OPENAI_API_KEY` は Next.js の API Route などサーバーサイド専用で利用し、
  クライアントには一切公開しない。
* クライアントから GPT-API を直接呼び出すことは禁止とし、
  必ず API Route 経由で間接的に呼び出す構成を取る。

## 2-6-3 削除ポリシーと tombstone

### 通常の削除（住人・会話など）

* 通常の削除（住人削除、会話ログ削除など）は、**tombstone によるソフトデリート**を基本とする。
* 同期や整合性管理のため、以下のフィールドを持つことを前提とする。

  * `deleted`: boolean（論理削除フラグ。削除時に `true`）
  * `updated_at`: timestamp（最終更新日時）
* 削除操作が行われた場合：

  * `deleted = true` に更新し、`updated_at` を現在時刻に更新する。
  * 物理削除は即時には行わず、tombstone を用いて他クライアントとの同期・競合解決に利用する。
* 競合解決の方針：

  * 基本は **最終更新勝ち**（`updated_at` が新しいレコードを採用）。
  * `deleted = true` のレコードは、「削除を優先」する扱いとする。

### アカウント削除（ユーザーデータ削除）

* ユーザーからのアカウント削除要求に対しては、
  **関連データを物理削除する**ことを原則とする。
* 想定フロー（概要）：

  1. ユーザーがアカウント削除を要求する。
  2. Service Role キー＋Drizzle 等を用いたサーバー側処理により、

     * 当該 `owner_id` を持つ全レコードを物理削除する（会話ログ・相談・住人・WorldFacts 等）。
  3. 必要に応じて Auth のユーザーアカウント自体も削除する。
* アカウント削除処理の詳細な実装（削除対象テーブル一覧・順序など）は、
  別ドキュメント（運用／管理者向け仕様）で定義する。

## 2-6-4 ログ / 監視（Sentry 等）

### Sentry に送信する情報の制限

* Reladen では、住人情報や会話・相談の内容が **個人情報／センシティブ情報になり得る**ため、
  ログ／監視に送信するデータからはこれらを極力排除する。

* Sentry に対しては、原則として以下のみを送信対象とする。

  * エラー種別・メッセージ（実装側で用意した定型文）
  * スタックトレース
  * 内部 ID（例：resident_id, world_id, conversation_id 等の UUID/数値 ID）
  * 環境情報（ブラウザ種別、OS、`SENTRY_ENVIRONMENT` 等）

* 特に **以下の情報は Sentry に送信しない方針**とする。

  * 住人の名前・プロフィールなど、ユーザーが入力した属性情報
  * 会話本文（住人同士のセリフ）
  * 相談内容テキスト
  * プレイヤーが自由入力したテキスト全般

* 自動的にリクエストボディや画面内テキストをキャプチャする機能がある場合は、
  可能な範囲で無効化・マスク・トリミング等を行い、
  「テキストコンテンツそのもの」が送信されないようにする。

### ログレベルと環境

* `SENTRY_ENVIRONMENT`（および将来導入される `NEXT_PUBLIC_APP_ENV` 等）に応じて、

  * 本番では詳細ログを抑制し、PII を含まない形でのエラー追跡に集中する。
  * 開発環境ではエラー情報をより詳細に収集するが、それでも個人情報テキストは送信しない。
* Sentry の DSN や認証トークンは環境変数で管理し、
  開発／本番で異なる値を用いることができる前提とする（実際の運用は別途定義）。

## 2-6-5 環境分離と権限管理

### 開発 / 本番環境の分離

* 現時点では本番公開前の段階であり、Supabase プロジェクトは 1 つで運用している。
* 将来的に Reladen を公開する際には、

  * **開発用 Supabase プロジェクト** と **本番用 Supabase プロジェクト** を分離することを前提とする。
  * 両環境で **同一のスキーマ構成**（Drizzle により管理）を維持する。
* Next.js / Vercel 側の環境変数により、
  各環境に対応した `NEXT_PUBLIC_SUPABASE_URL` / `NEXT_PUBLIC_SUPABASE_ANON_KEY` / `DATABASE_URL` 等を切り替えられるようにする。

### GPT / Sentry 等の鍵

* GPT（OpenAI）や Sentry の鍵・DSN についても、
  環境ごとに分けて運用できる構成とする（実際に同一値を使うかどうかは運用上の判断）。
* 共通ルール：

  * いずれの環境でも、**鍵類は必ずサーバーサイド専用の環境変数で管理**し、
    `NEXT_PUBLIC_` プレフィックスの変数には含めない。
  * 不要に権限の強い鍵を作成せず、最小権限原則（least privilege）を意識する。

---

本章で定義したセキュリティ / RLS 方針は、
後続の章（会話・相談・WorldFacts・同期など）の設計に対しても共通の前提として適用される。