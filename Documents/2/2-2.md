# 2-2 データフロー

Reladen は、Supabase を正本としつつ、ローカル DB（IndexedDB / `app.db`）との同期、および GPT-API を用いた生成処理によって動作する。  
本節では、特に以下のデータフローを概説する。

- 会話生成（スケジューラ起点）
- WorldFacts 生成と TopicThreads への派生
- Supabase とローカル DB の同期（tombstone / `updated_at` ベース）
- Supabase Realtime による更新伝播

## 2-2-1 会話生成フロー（スケジューラ起点）

会話生成は、**すべてサーバー側スケジューラから起動される**ことを前提とする。

1. **スケジューラによるペア選定**
   - サーバー側のスケジューラが、起床中の住人ペア・時間帯・関係・印象・WorldFacts/Topic 等を考慮し、  
     「この時間帯に会話を行う住人ペア」を自動的に選定する。
   - 選定ロジックの詳細は、会話ロジックの章で定義する。

2. **API Route へのトリガ**
   - スケジューラは Next.js の API Route（例：`POST /app/api/conversations/start`）を呼び出し、  
     対象ペア・世界時間など、会話生成に必要な最小限の情報を渡す。

3. **サーバー側での条件集約**
   - API Route 内で、Supabase から以下の情報を取得・集約する。
     - 住人プロフィール・性格パラメータ
     - 関係・印象
     - 関連する WorldFacts / TopicThreads
     - 現在の世界時間帯・天気など
   - これらをプロンプトとして組み立て、GPT-API に送信する。

4. **GPT-API による会話生成**
   - GPT-API は、与えられた条件に基づいて会話テキストを生成する。
   - 返却されたテキストは、会話ログ用の構造（発話単位・メタ情報等）に整形される。

5. **会話レコードの保存**
   - 整形された会話ログおよび関連メタデータは、Supabase（会話テーブル群）に保存される。
   - 必要に応じて、WorldFacts/Topic の「消化状況」等が更新される（後述）。

6. **クライアントへの反映**
   - クライアントは、Supabase からの取得・同期、もしくは Realtime 通知を通じて、
     新規会話が発生したことを検知し、ローカル DB に反映する。
   - クライアントから GPT-API を直接呼び出すことはなく、  
     あくまで「保存済みの会話ログ」を表示・操作する。

## 2-2-2 WorldFacts と TopicThreads のフロー

WorldFacts は、世界内での出来事を表すデータであり、  
そこから派生する「話題のスレッド」として `topic_threads` を利用する。

1. **WorldFacts の生成**
   - サーバー側スケジューラが、一定間隔で WorldFacts 生成処理を起動する（バッチ起動）。
   - スケジューラは Next.js の API Route（例：`POST /app/api/world-facts/generate`）を呼び出す。
   - API Route 内で、現在の世界状態・既存の WorldFacts を踏まえ、GPT-API に対して新規 WorldFacts の生成を依頼する。
   - 生成された WorldFacts は Supabase の該当テーブルに保存される。

2. **TopicThreads への派生**
   - 新規 WorldFacts 保存時、もしくは専用のバッチ処理により、
     WorldFacts から `topic_threads`（会話などで利用される話題スレッド）を派生させる。
   - `topic_threads` には、少なくとも以下の情報を保持する。
     - WorldFacts との紐付け
     - 話題の種類・カテゴリー
     - 優先度（高／中／低 等）
     - 有効期限（いつまでこの話題を優先的に扱うか）  
       ※ 詳細なスキーマやロジックは、会話ロジック／イベント設計の章で定義する。

3. **消化状況の管理（概要）**
   - 会話生成時に、どの `topic_threads` が利用されたかを記録し、  
     利用済み・未利用・期限切れ等の状態を更新する。
   - 本章では詳細ロジックには踏み込まず、  
     「WorldFacts → TopicThreads → 会話で消費」という大まかな流れのみ定義する。

## 2-2-3 同期フロー（Supabase ↔ ローカル DB）

Reladen は「Supabase 正本・ローカルはキャッシュ＋短期オフライン編集」という前提で、  
`updated_at` と `deleted`（tombstone）を利用した同期を行う。

1. **共通フィールド**
   - 同期対象テーブルには、少なくとも以下のフィールドを持たせる。
     - `updated_at`: 最終更新日時（サーバー側で管理）
     - `deleted`: 論理削除フラグ（tombstone）
   - 物理削除は基本的に行わず、`deleted = true` を tombstone として扱う。

2. **オンライン時の基本動作**
   - 通常のオンライン状態では、クライアントは Supabase SDK を用いて  
     `select` / `insert` / `update` 等を直接実行し、`updated_at` はサーバー側で更新される。
   - ローカル DB（IndexedDB / `app.db`）には、取得結果をキャッシュする形で反映する。

3. **オフライン時の変更とキュー**
   - ネットワーク断などにより Supabase への書き込みが行えない場合、  
     クライアントはローカル DB に対して変更を行い、「未同期の変更」として保持する。
   - 未同期の変更の保持方法（専用キュー／各レコードのフラグ等）は実装詳細とし、  
     本仕様では「オフラインでの変更がオンライン復帰時にまとめて送信される」ことのみを定義する。

4. **同期 API（`/app/api/sync/{table}`）**
   - オンライン復帰時、または手動同期トリガ時に、クライアントは  
     `/app/api/sync/{table}` に対してローカル側の差分情報を送信する。
   - API Route 側では、Supabase の該当テーブルとローカル差分を突き合わせてマージし、  
     マージ結果をクライアントに返却する。
   - 競合が発生した場合の基本ポリシーは、**最終更新勝ち（`updated_at` が新しい方を採用）** とする。
     - 特に、`deleted = true` の tombstone は「削除を優先」する運用とし、  
       物理削除は別途バッチ処理等で行う。

5. **ローカル DB への反映**
   - 同期 API の結果を受けて、クライアントはローカル DB を更新し、  
     未同期フラグやキューを解消する。
   - これにより、「Supabase 正本」「ローカルキャッシュ」が整合した状態に戻る。

## 2-2-4 Supabase Realtime による更新伝播

複数クライアント間での更新反映の遅延を抑えるため、Supabase Realtime を利用する。

1. **テーブル別チャンネル**
   - residents や relationships / impressions 等の主要テーブルに対して、  
     テーブル別の Realtime チャンネルを購読する。
   - これらのチャンネルで「更新があった」ことを検知した場合、  
     クライアントは対象テーブルに対して `/app/api/sync/{table}` を呼び出し、  
     **テーブル単位の再同期**を行う。
   - これにより、他クライアントの変更が短時間でローカル DB に反映される。

2. **イベント／通知用チャンネル**
   - 相談の新規発生や、一部のイベント通知等については、  
     専用の Realtime チャンネル（events/notifications 等）を用いる。
   - これらのチャンネルでは、1 行分のデータ（もしくはそれに準じるペイロード）を受信し、  
     受信した内容を**そのままローカル DB に反映**する（行単位同期）。
   - 必要に応じて、該当テーブルの再同期を追加で行うこともできるが、  
     本仕様では「行レベルで直接反映できるケース」を優先する。

3. **Realtime と同期処理の関係**
   - Realtime はあくまで「変更があったことを素早く知るためのトリガ」であり、  
     正本の整合性は `/app/api/sync/{table}` および Supabase そのものが担う。
   - クライアントは、Realtime 通知 → 必要に応じて同期 API → ローカル DB 更新、  
     という流れで最新状態を追従する。
