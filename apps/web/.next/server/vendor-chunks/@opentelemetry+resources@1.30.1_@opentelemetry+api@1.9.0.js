"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/Resource.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/Resource.js ***!
  \*****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Resource: () => (/* binding */ Resource)\n/* harmony export */ });\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag-api.js\");\n/* harmony import */ var _opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.28.0/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js\");\n/* harmony import */ var _opentelemetry_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+core@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/node/sdk-info.js\");\n/* harmony import */ var _platform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\");\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __read = (undefined && undefined.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\n\n\n\n\n/**\n * A Resource describes the entity for which a signals (metrics or trace) are\n * collected.\n */\nvar Resource = /** @class */ (function () {\n    function Resource(\n    /**\n     * A dictionary of attributes with string keys and values that provide\n     * information about the entity as numbers, strings or booleans\n     * TODO: Consider to add check/validation on attributes.\n     */\n    attributes, asyncAttributesPromise) {\n        var _this = this;\n        var _a;\n        this._attributes = attributes;\n        this.asyncAttributesPending = asyncAttributesPromise != null;\n        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};\n        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then(function (asyncAttributes) {\n            _this._attributes = Object.assign({}, _this._attributes, asyncAttributes);\n            _this.asyncAttributesPending = false;\n            return asyncAttributes;\n        }, function (err) {\n            _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.diag.debug(\"a resource's async attributes promise rejected: %s\", err);\n            _this.asyncAttributesPending = false;\n            return {};\n        });\n    }\n    /**\n     * Returns an empty Resource\n     */\n    Resource.empty = function () {\n        return Resource.EMPTY;\n    };\n    /**\n     * Returns a Resource that identifies the SDK in use.\n     */\n    Resource.default = function () {\n        var _a;\n        return new Resource((_a = {},\n            _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_SERVICE_NAME] = (0,_platform__WEBPACK_IMPORTED_MODULE_2__.defaultServiceName)(),\n            _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE] = _opentelemetry_core__WEBPACK_IMPORTED_MODULE_3__.SDK_INFO[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE],\n            _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_NAME] = _opentelemetry_core__WEBPACK_IMPORTED_MODULE_3__.SDK_INFO[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_NAME],\n            _a[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_VERSION] = _opentelemetry_core__WEBPACK_IMPORTED_MODULE_3__.SDK_INFO[_opentelemetry_semantic_conventions__WEBPACK_IMPORTED_MODULE_1__.SEMRESATTRS_TELEMETRY_SDK_VERSION],\n            _a));\n    };\n    Object.defineProperty(Resource.prototype, \"attributes\", {\n        get: function () {\n            var _a;\n            if (this.asyncAttributesPending) {\n                _opentelemetry_api__WEBPACK_IMPORTED_MODULE_0__.diag.error('Accessing resource attributes before async attributes settled');\n            }\n            return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to\n     * this Resource's attributes. This is useful in exporters to block until resource detection\n     * has finished.\n     */\n    Resource.prototype.waitForAsyncAttributes = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.asyncAttributesPending) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this._asyncAttributesPromise];\n                    case 1:\n                        _a.sent();\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a new, merged {@link Resource} by merging the current Resource\n     * with the other Resource. In case of a collision, other Resource takes\n     * precedence.\n     *\n     * @param other the Resource that will be merged with this.\n     * @returns the newly merged Resource.\n     */\n    Resource.prototype.merge = function (other) {\n        var _this = this;\n        var _a;\n        if (!other)\n            return this;\n        // SpanAttributes from other resource overwrite attributes from this resource.\n        var mergedSyncAttributes = __assign(__assign({}, this._syncAttributes), ((_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes));\n        if (!this._asyncAttributesPromise &&\n            !other._asyncAttributesPromise) {\n            return new Resource(mergedSyncAttributes);\n        }\n        var mergedAttributesPromise = Promise.all([\n            this._asyncAttributesPromise,\n            other._asyncAttributesPromise,\n        ]).then(function (_a) {\n            var _b;\n            var _c = __read(_a, 2), thisAsyncAttributes = _c[0], otherAsyncAttributes = _c[1];\n            return __assign(__assign(__assign(__assign({}, _this._syncAttributes), thisAsyncAttributes), ((_b = other._syncAttributes) !== null && _b !== void 0 ? _b : other.attributes)), otherAsyncAttributes);\n        });\n        return new Resource(mergedSyncAttributes, mergedAttributesPromise);\n    };\n    Resource.EMPTY = new Resource({});\n    return Resource;\n}());\n\n//# sourceMappingURL=Resource.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStyZXNvdXJjZXNAMS4zMC4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9SZXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFJLElBQUksU0FBSTtBQUM1QjtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsU0FBSSxJQUFJLFNBQUk7QUFDL0IsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBLGNBQWMsU0FBSSxJQUFJLFNBQUk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQzBDO0FBQzZJO0FBQ3hJO0FBQ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsWUFBWSxvREFBSTtBQUNoQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlLHlGQUF3QixJQUFJLDZEQUFrQjtBQUM3RCxlQUFlLG1HQUFrQyxJQUFJLHlEQUFRLENBQUMsbUdBQWtDO0FBQ2hHLGVBQWUsK0ZBQThCLElBQUkseURBQVEsQ0FBQywrRkFBOEI7QUFDeEYsZUFBZSxrR0FBaUMsSUFBSSx5REFBUSxDQUFDLGtHQUFpQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQUk7QUFDcEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLENBQUM7QUFDbUI7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K3Jlc291cmNlc0AxLjMwLjFfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9yZXNvdXJjZXMvYnVpbGQvZXNtL1Jlc291cmNlLmpzP2Q4ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuaW1wb3J0IHsgZGlhZyB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L2FwaSc7XG5pbXBvcnQgeyBTRU1SRVNBVFRSU19TRVJWSUNFX05BTUUsIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTEFOR1VBR0UsIFNFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTkFNRSwgU0VNUkVTQVRUUlNfVEVMRU1FVFJZX1NES19WRVJTSU9OLCB9IGZyb20gJ0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zJztcbmltcG9ydCB7IFNES19JTkZPIH0gZnJvbSAnQG9wZW50ZWxlbWV0cnkvY29yZSc7XG5pbXBvcnQgeyBkZWZhdWx0U2VydmljZU5hbWUgfSBmcm9tICcuL3BsYXRmb3JtJztcbi8qKlxuICogQSBSZXNvdXJjZSBkZXNjcmliZXMgdGhlIGVudGl0eSBmb3Igd2hpY2ggYSBzaWduYWxzIChtZXRyaWNzIG9yIHRyYWNlKSBhcmVcbiAqIGNvbGxlY3RlZC5cbiAqL1xudmFyIFJlc291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlKFxuICAgIC8qKlxuICAgICAqIEEgZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGVzIHdpdGggc3RyaW5nIGtleXMgYW5kIHZhbHVlcyB0aGF0IHByb3ZpZGVcbiAgICAgKiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZW50aXR5IGFzIG51bWJlcnMsIHN0cmluZ3Mgb3IgYm9vbGVhbnNcbiAgICAgKiBUT0RPOiBDb25zaWRlciB0byBhZGQgY2hlY2svdmFsaWRhdGlvbiBvbiBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZXMsIGFzeW5jQXR0cmlidXRlc1Byb21pc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5hc3luY0F0dHJpYnV0ZXNQZW5kaW5nID0gYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSAhPSBudWxsO1xuICAgICAgICB0aGlzLl9zeW5jQXR0cmlidXRlcyA9IChfYSA9IHRoaXMuX2F0dHJpYnV0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICB0aGlzLl9hc3luY0F0dHJpYnV0ZXNQcm9taXNlID0gYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSA9PT0gbnVsbCB8fCBhc3luY0F0dHJpYnV0ZXNQcm9taXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhc3luY0F0dHJpYnV0ZXNQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGFzeW5jQXR0cmlidXRlcykge1xuICAgICAgICAgICAgX3RoaXMuX2F0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBfdGhpcy5fYXR0cmlidXRlcywgYXN5bmNBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIF90aGlzLmFzeW5jQXR0cmlidXRlc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0F0dHJpYnV0ZXM7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGRpYWcuZGVidWcoXCJhIHJlc291cmNlJ3MgYXN5bmMgYXR0cmlidXRlcyBwcm9taXNlIHJlamVjdGVkOiAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgX3RoaXMuYXN5bmNBdHRyaWJ1dGVzUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlbXB0eSBSZXNvdXJjZVxuICAgICAqL1xuICAgIFJlc291cmNlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2UuRU1QVFk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUmVzb3VyY2UgdGhhdCBpZGVudGlmaWVzIHRoZSBTREsgaW4gdXNlLlxuICAgICAqL1xuICAgIFJlc291cmNlLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZSgoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW1NFTVJFU0FUVFJTX1NFUlZJQ0VfTkFNRV0gPSBkZWZhdWx0U2VydmljZU5hbWUoKSxcbiAgICAgICAgICAgIF9hW1NFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfTEFOR1VBR0VdID0gU0RLX0lORk9bU0VNUkVTQVRUUlNfVEVMRU1FVFJZX1NES19MQU5HVUFHRV0sXG4gICAgICAgICAgICBfYVtTRU1SRVNBVFRSU19URUxFTUVUUllfU0RLX05BTUVdID0gU0RLX0lORk9bU0VNUkVTQVRUUlNfVEVMRU1FVFJZX1NES19OQU1FXSxcbiAgICAgICAgICAgIF9hW1NFTVJFU0FUVFJTX1RFTEVNRVRSWV9TREtfVkVSU0lPTl0gPSBTREtfSU5GT1tTRU1SRVNBVFRSU19URUxFTUVUUllfU0RLX1ZFUlNJT05dLFxuICAgICAgICAgICAgX2EpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXNvdXJjZS5wcm90b3R5cGUsIFwiYXR0cmlidXRlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXN5bmNBdHRyaWJ1dGVzUGVuZGluZykge1xuICAgICAgICAgICAgICAgIGRpYWcuZXJyb3IoJ0FjY2Vzc2luZyByZXNvdXJjZSBhdHRyaWJ1dGVzIGJlZm9yZSBhc3luYyBhdHRyaWJ1dGVzIHNldHRsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9hdHRyaWJ1dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBuZXZlciBiZSByZWplY3RlZC4gUmVzb2x2ZXMgd2hlbiBhbGwgYXN5bmMgYXR0cmlidXRlcyBoYXZlIGZpbmlzaGVkIGJlaW5nIGFkZGVkIHRvXG4gICAgICogdGhpcyBSZXNvdXJjZSdzIGF0dHJpYnV0ZXMuIFRoaXMgaXMgdXNlZnVsIGluIGV4cG9ydGVycyB0byBibG9jayB1bnRpbCByZXNvdXJjZSBkZXRlY3Rpb25cbiAgICAgKiBoYXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgUmVzb3VyY2UucHJvdG90eXBlLndhaXRGb3JBc3luY0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hc3luY0F0dHJpYnV0ZXNQZW5kaW5nKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2FzeW5jQXR0cmlidXRlc1Byb21pc2VdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcsIG1lcmdlZCB7QGxpbmsgUmVzb3VyY2V9IGJ5IG1lcmdpbmcgdGhlIGN1cnJlbnQgUmVzb3VyY2VcbiAgICAgKiB3aXRoIHRoZSBvdGhlciBSZXNvdXJjZS4gSW4gY2FzZSBvZiBhIGNvbGxpc2lvbiwgb3RoZXIgUmVzb3VyY2UgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIHRoZSBSZXNvdXJjZSB0aGF0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhpcy5cbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3bHkgbWVyZ2VkIFJlc291cmNlLlxuICAgICAqL1xuICAgIFJlc291cmNlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghb3RoZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgLy8gU3BhbkF0dHJpYnV0ZXMgZnJvbSBvdGhlciByZXNvdXJjZSBvdmVyd3JpdGUgYXR0cmlidXRlcyBmcm9tIHRoaXMgcmVzb3VyY2UuXG4gICAgICAgIHZhciBtZXJnZWRTeW5jQXR0cmlidXRlcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLl9zeW5jQXR0cmlidXRlcyksICgoX2EgPSBvdGhlci5fc3luY0F0dHJpYnV0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG90aGVyLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY0F0dHJpYnV0ZXNQcm9taXNlICYmXG4gICAgICAgICAgICAhb3RoZXIuX2FzeW5jQXR0cmlidXRlc1Byb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2UobWVyZ2VkU3luY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXJnZWRBdHRyaWJ1dGVzUHJvbWlzZSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jQXR0cmlidXRlc1Byb21pc2UsXG4gICAgICAgICAgICBvdGhlci5fYXN5bmNBdHRyaWJ1dGVzUHJvbWlzZSxcbiAgICAgICAgXSkudGhlbihmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYjtcbiAgICAgICAgICAgIHZhciBfYyA9IF9fcmVhZChfYSwgMiksIHRoaXNBc3luY0F0dHJpYnV0ZXMgPSBfY1swXSwgb3RoZXJBc3luY0F0dHJpYnV0ZXMgPSBfY1sxXTtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgX3RoaXMuX3N5bmNBdHRyaWJ1dGVzKSwgdGhpc0FzeW5jQXR0cmlidXRlcyksICgoX2IgPSBvdGhlci5fc3luY0F0dHJpYnV0ZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG90aGVyLmF0dHJpYnV0ZXMpKSwgb3RoZXJBc3luY0F0dHJpYnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZShtZXJnZWRTeW5jQXR0cmlidXRlcywgbWVyZ2VkQXR0cmlidXRlc1Byb21pc2UpO1xuICAgIH07XG4gICAgUmVzb3VyY2UuRU1QVFkgPSBuZXcgUmVzb3VyY2Uoe30pO1xuICAgIHJldHVybiBSZXNvdXJjZTtcbn0oKSk7XG5leHBvcnQgeyBSZXNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzb3VyY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/Resource.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js":
/*!*******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js ***!
  \*******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultServiceName: () => (/* binding */ defaultServiceName)\n/* harmony export */ });\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction defaultServiceName() {\n    return \"unknown_service:\" + process.argv0;\n}\n//# sourceMappingURL=default-service-name.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStyZXNvdXJjZXNAMS4zMC4xX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzL2J1aWxkL2VzbS9wbGF0Zm9ybS9ub2RlL2RlZmF1bHQtc2VydmljZS1uYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkrcmVzb3VyY2VzQDEuMzAuMV9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L3Jlc291cmNlcy9idWlsZC9lc20vcGxhdGZvcm0vbm9kZS9kZWZhdWx0LXNlcnZpY2UtbmFtZS5qcz8zNzM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgVGhlIE9wZW5UZWxlbWV0cnkgQXV0aG9yc1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFNlcnZpY2VOYW1lKCkge1xuICAgIHJldHVybiBcInVua25vd25fc2VydmljZTpcIiArIHByb2Nlc3MuYXJndjA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXNlcnZpY2UtbmFtZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+resources@1.30.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/resources/build/esm/platform/node/default-service-name.js\n");

/***/ })

};
;