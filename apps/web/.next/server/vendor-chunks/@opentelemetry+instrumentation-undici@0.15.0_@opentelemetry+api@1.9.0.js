"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SemanticAttributes = void 0;\n// DO NOT EDIT, this is an Auto-generated file from scripts/semconv/templates//templates/SemanticAttributes.ts.j2\nexports.SemanticAttributes = {\n    /**\n     * State of the HTTP connection in the HTTP connection pool.\n     */\n    HTTP_CONNECTION_STATE: 'http.connection.state',\n    /**\n    * Describes a class of error the operation ended with.\n    *\n    * Note: The `error.type` SHOULD be predictable and SHOULD have low cardinality.\n  Instrumentations SHOULD document the list of errors they report.\n  \n  The cardinality of `error.type` within one instrumentation library SHOULD be low.\n  Telemetry consumers that aggregate data from multiple instrumentation libraries and applications\n  should be prepared for `error.type` to have high cardinality at query time when no\n  additional filters are applied.\n  \n  If the operation has completed successfully, instrumentations SHOULD NOT set `error.type`.\n  \n  If a specific domain defines its own set of error identifiers (such as HTTP or gRPC status codes),\n  it&#39;s RECOMMENDED to:\n  \n  * Use a domain-specific attribute\n  * Set `error.type` to capture all errors, regardless of whether they are defined within the domain-specific set or not.\n    */\n    ERROR_TYPE: 'error.type',\n    /**\n     * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.\n     */\n    HTTP_REQUEST_BODY_SIZE: 'http.request.body.size',\n    /**\n    * HTTP request method.\n    *\n    * Note: HTTP request method value SHOULD be &#34;known&#34; to the instrumentation.\n  By default, this convention defines &#34;known&#34; methods as the ones listed in [RFC9110](https://www.rfc-editor.org/rfc/rfc9110.html#name-methods)\n  and the PATCH method defined in [RFC5789](https://www.rfc-editor.org/rfc/rfc5789.html).\n  \n  If the HTTP request method is not known to instrumentation, it MUST set the `http.request.method` attribute to `_OTHER`.\n  \n  If the HTTP instrumentation could end up converting valid HTTP request methods to `_OTHER`, then it MUST provide a way to override\n  the list of known HTTP methods. If this override is done via environment variable, then the environment variable MUST be named\n  OTEL_INSTRUMENTATION_HTTP_KNOWN_METHODS and support a comma-separated list of case-sensitive known HTTP methods\n  (this list MUST be a full override of the default known method, it is not a list of known methods in addition to the defaults).\n  \n  HTTP method names are case-sensitive and `http.request.method` attribute value MUST match a known HTTP method name exactly.\n  Instrumentations for specific web frameworks that consider HTTP methods to be case insensitive, SHOULD populate a canonical equivalent.\n  Tracing instrumentations that do so, MUST also set `http.request.method_original` to the original value.\n    */\n    HTTP_REQUEST_METHOD: 'http.request.method',\n    /**\n     * Original HTTP method sent by the client in the request line.\n     */\n    HTTP_REQUEST_METHOD_ORIGINAL: 'http.request.method_original',\n    /**\n     * The ordinal number of request resending attempt (for any reason, including redirects).\n     *\n     * Note: The resend count SHOULD be updated each time an HTTP request gets resent by the client, regardless of what was the cause of the resending (e.g. redirection, authorization failure, 503 Server Unavailable, network issues, or any other).\n     */\n    HTTP_REQUEST_RESEND_COUNT: 'http.request.resend_count',\n    /**\n     * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://www.rfc-editor.org/rfc/rfc9110.html#field.content-length) header. For requests using transport encoding, this should be the compressed size.\n     */\n    HTTP_RESPONSE_BODY_SIZE: 'http.response.body.size',\n    /**\n     * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).\n     */\n    HTTP_RESPONSE_STATUS_CODE: 'http.response.status_code',\n    /**\n    * The matched route, that is, the path template in the format used by the respective server framework.\n    *\n    * Note: MUST NOT be populated when this is not supported by the HTTP server framework as the route attribute should have low-cardinality and the URI path can NOT substitute it.\n  SHOULD include the [application root](/docs/http/http-spans.md#http-server-definitions) if there is one.\n    */\n    HTTP_ROUTE: 'http.route',\n    /**\n     * Peer address of the network connection - IP address or Unix domain socket name.\n     */\n    NETWORK_PEER_ADDRESS: 'network.peer.address',\n    /**\n     * Peer port number of the network connection.\n     */\n    NETWORK_PEER_PORT: 'network.peer.port',\n    /**\n     * [OSI application layer](https://osi-model.com/application-layer/) or non-OSI equivalent.\n     *\n     * Note: The value SHOULD be normalized to lowercase.\n     */\n    NETWORK_PROTOCOL_NAME: 'network.protocol.name',\n    /**\n     * Version of the protocol specified in `network.protocol.name`.\n     *\n     * Note: `network.protocol.version` refers to the version of the protocol used and might be different from the protocol client&#39;s version. If the HTTP client has a version of `0.27.2`, but sends HTTP version `1.1`, this attribute should be set to `1.1`.\n     */\n    NETWORK_PROTOCOL_VERSION: 'network.protocol.version',\n    /**\n     * Server domain name if available without reverse DNS lookup; otherwise, IP address or Unix domain socket name.\n     *\n     * Note: When observed from the client side, and when communicating through an intermediary, `server.address` SHOULD represent the server address behind any intermediaries, for example proxies, if it&#39;s available.\n     */\n    SERVER_ADDRESS: 'server.address',\n    /**\n     * Server port number.\n     *\n     * Note: When observed from the client side, and when communicating through an intermediary, `server.port` SHOULD represent the server port behind any intermediaries, for example proxies, if it&#39;s available.\n     */\n    SERVER_PORT: 'server.port',\n    /**\n    * Absolute URL describing a network resource according to [RFC3986](https://www.rfc-editor.org/rfc/rfc3986).\n    *\n    * Note: For network calls, URL usually has `scheme://host[:port][path][?query][#fragment]` format, where the fragment is not transmitted over HTTP, but if it is known, it SHOULD be included nevertheless.\n  `url.full` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case username and password SHOULD be redacted and attribute&#39;s value SHOULD be `https://REDACTED:REDACTED@www.example.com/`.\n  `url.full` SHOULD capture the absolute URL when it is available (or can be reconstructed) and SHOULD NOT be validated or modified except for sanitizing purposes.\n    */\n    URL_FULL: 'url.full',\n    /**\n     * The [URI path](https://www.rfc-editor.org/rfc/rfc3986#section-3.3) component.\n     */\n    URL_PATH: 'url.path',\n    /**\n     * The [URI query](https://www.rfc-editor.org/rfc/rfc3986#section-3.4) component.\n     *\n     * Note: Sensitive content provided in query string SHOULD be scrubbed when instrumentations can identify it.\n     */\n    URL_QUERY: 'url.query',\n    /**\n     * The [URI scheme](https://www.rfc-editor.org/rfc/rfc3986#section-3.1) component identifying the used protocol.\n     */\n    URL_SCHEME: 'url.scheme',\n    /**\n     * Value of the [HTTP User-Agent](https://www.rfc-editor.org/rfc/rfc9110.html#field.user-agent) header sent by the client.\n     */\n    USER_AGENT_ORIGINAL: 'user_agent.original',\n};\n//# sourceMappingURL=SemanticAttributes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL2VudW1zL1NlbWFudGljQXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SUFBdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsZ05BQWdOO0FBQ2hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwTUFBME07QUFDMU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMExBQTBMO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi11bmRpY2lAMC4xNS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9idWlsZC9zcmMvZW51bXMvU2VtYW50aWNBdHRyaWJ1dGVzLmpzPzNlZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW1hbnRpY0F0dHJpYnV0ZXMgPSB2b2lkIDA7XG4vLyBETyBOT1QgRURJVCwgdGhpcyBpcyBhbiBBdXRvLWdlbmVyYXRlZCBmaWxlIGZyb20gc2NyaXB0cy9zZW1jb252L3RlbXBsYXRlcy8vdGVtcGxhdGVzL1NlbWFudGljQXR0cmlidXRlcy50cy5qMlxuZXhwb3J0cy5TZW1hbnRpY0F0dHJpYnV0ZXMgPSB7XG4gICAgLyoqXG4gICAgICogU3RhdGUgb2YgdGhlIEhUVFAgY29ubmVjdGlvbiBpbiB0aGUgSFRUUCBjb25uZWN0aW9uIHBvb2wuXG4gICAgICovXG4gICAgSFRUUF9DT05ORUNUSU9OX1NUQVRFOiAnaHR0cC5jb25uZWN0aW9uLnN0YXRlJyxcbiAgICAvKipcbiAgICAqIERlc2NyaWJlcyBhIGNsYXNzIG9mIGVycm9yIHRoZSBvcGVyYXRpb24gZW5kZWQgd2l0aC5cbiAgICAqXG4gICAgKiBOb3RlOiBUaGUgYGVycm9yLnR5cGVgIFNIT1VMRCBiZSBwcmVkaWN0YWJsZSBhbmQgU0hPVUxEIGhhdmUgbG93IGNhcmRpbmFsaXR5LlxuICBJbnN0cnVtZW50YXRpb25zIFNIT1VMRCBkb2N1bWVudCB0aGUgbGlzdCBvZiBlcnJvcnMgdGhleSByZXBvcnQuXG4gIFxuICBUaGUgY2FyZGluYWxpdHkgb2YgYGVycm9yLnR5cGVgIHdpdGhpbiBvbmUgaW5zdHJ1bWVudGF0aW9uIGxpYnJhcnkgU0hPVUxEIGJlIGxvdy5cbiAgVGVsZW1ldHJ5IGNvbnN1bWVycyB0aGF0IGFnZ3JlZ2F0ZSBkYXRhIGZyb20gbXVsdGlwbGUgaW5zdHJ1bWVudGF0aW9uIGxpYnJhcmllcyBhbmQgYXBwbGljYXRpb25zXG4gIHNob3VsZCBiZSBwcmVwYXJlZCBmb3IgYGVycm9yLnR5cGVgIHRvIGhhdmUgaGlnaCBjYXJkaW5hbGl0eSBhdCBxdWVyeSB0aW1lIHdoZW4gbm9cbiAgYWRkaXRpb25hbCBmaWx0ZXJzIGFyZSBhcHBsaWVkLlxuICBcbiAgSWYgdGhlIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgaW5zdHJ1bWVudGF0aW9ucyBTSE9VTEQgTk9UIHNldCBgZXJyb3IudHlwZWAuXG4gIFxuICBJZiBhIHNwZWNpZmljIGRvbWFpbiBkZWZpbmVzIGl0cyBvd24gc2V0IG9mIGVycm9yIGlkZW50aWZpZXJzIChzdWNoIGFzIEhUVFAgb3IgZ1JQQyBzdGF0dXMgY29kZXMpLFxuICBpdCYjMzk7cyBSRUNPTU1FTkRFRCB0bzpcbiAgXG4gICogVXNlIGEgZG9tYWluLXNwZWNpZmljIGF0dHJpYnV0ZVxuICAqIFNldCBgZXJyb3IudHlwZWAgdG8gY2FwdHVyZSBhbGwgZXJyb3JzLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleSBhcmUgZGVmaW5lZCB3aXRoaW4gdGhlIGRvbWFpbi1zcGVjaWZpYyBzZXQgb3Igbm90LlxuICAgICovXG4gICAgRVJST1JfVFlQRTogJ2Vycm9yLnR5cGUnLFxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSByZXF1ZXN0IHBheWxvYWQgYm9keSBpbiBieXRlcy4gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRyYW5zZmVycmVkIGV4Y2x1ZGluZyBoZWFkZXJzIGFuZCBpcyBvZnRlbiwgYnV0IG5vdCBhbHdheXMsIHByZXNlbnQgYXMgdGhlIFtDb250ZW50LUxlbmd0aF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LWxlbmd0aCkgaGVhZGVyLiBGb3IgcmVxdWVzdHMgdXNpbmcgdHJhbnNwb3J0IGVuY29kaW5nLCB0aGlzIHNob3VsZCBiZSB0aGUgY29tcHJlc3NlZCBzaXplLlxuICAgICAqL1xuICAgIEhUVFBfUkVRVUVTVF9CT0RZX1NJWkU6ICdodHRwLnJlcXVlc3QuYm9keS5zaXplJyxcbiAgICAvKipcbiAgICAqIEhUVFAgcmVxdWVzdCBtZXRob2QuXG4gICAgKlxuICAgICogTm90ZTogSFRUUCByZXF1ZXN0IG1ldGhvZCB2YWx1ZSBTSE9VTEQgYmUgJiMzNDtrbm93biYjMzQ7IHRvIHRoZSBpbnN0cnVtZW50YXRpb24uXG4gIEJ5IGRlZmF1bHQsIHRoaXMgY29udmVudGlvbiBkZWZpbmVzICYjMzQ7a25vd24mIzM0OyBtZXRob2RzIGFzIHRoZSBvbmVzIGxpc3RlZCBpbiBbUkZDOTExMF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkxMTAuaHRtbCNuYW1lLW1ldGhvZHMpXG4gIGFuZCB0aGUgUEFUQ0ggbWV0aG9kIGRlZmluZWQgaW4gW1JGQzU3ODldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM1Nzg5Lmh0bWwpLlxuICBcbiAgSWYgdGhlIEhUVFAgcmVxdWVzdCBtZXRob2QgaXMgbm90IGtub3duIHRvIGluc3RydW1lbnRhdGlvbiwgaXQgTVVTVCBzZXQgdGhlIGBodHRwLnJlcXVlc3QubWV0aG9kYCBhdHRyaWJ1dGUgdG8gYF9PVEhFUmAuXG4gIFxuICBJZiB0aGUgSFRUUCBpbnN0cnVtZW50YXRpb24gY291bGQgZW5kIHVwIGNvbnZlcnRpbmcgdmFsaWQgSFRUUCByZXF1ZXN0IG1ldGhvZHMgdG8gYF9PVEhFUmAsIHRoZW4gaXQgTVVTVCBwcm92aWRlIGEgd2F5IHRvIG92ZXJyaWRlXG4gIHRoZSBsaXN0IG9mIGtub3duIEhUVFAgbWV0aG9kcy4gSWYgdGhpcyBvdmVycmlkZSBpcyBkb25lIHZpYSBlbnZpcm9ubWVudCB2YXJpYWJsZSwgdGhlbiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgTVVTVCBiZSBuYW1lZFxuICBPVEVMX0lOU1RSVU1FTlRBVElPTl9IVFRQX0tOT1dOX01FVEhPRFMgYW5kIHN1cHBvcnQgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjYXNlLXNlbnNpdGl2ZSBrbm93biBIVFRQIG1ldGhvZHNcbiAgKHRoaXMgbGlzdCBNVVNUIGJlIGEgZnVsbCBvdmVycmlkZSBvZiB0aGUgZGVmYXVsdCBrbm93biBtZXRob2QsIGl0IGlzIG5vdCBhIGxpc3Qgb2Yga25vd24gbWV0aG9kcyBpbiBhZGRpdGlvbiB0byB0aGUgZGVmYXVsdHMpLlxuICBcbiAgSFRUUCBtZXRob2QgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlIGFuZCBgaHR0cC5yZXF1ZXN0Lm1ldGhvZGAgYXR0cmlidXRlIHZhbHVlIE1VU1QgbWF0Y2ggYSBrbm93biBIVFRQIG1ldGhvZCBuYW1lIGV4YWN0bHkuXG4gIEluc3RydW1lbnRhdGlvbnMgZm9yIHNwZWNpZmljIHdlYiBmcmFtZXdvcmtzIHRoYXQgY29uc2lkZXIgSFRUUCBtZXRob2RzIHRvIGJlIGNhc2UgaW5zZW5zaXRpdmUsIFNIT1VMRCBwb3B1bGF0ZSBhIGNhbm9uaWNhbCBlcXVpdmFsZW50LlxuICBUcmFjaW5nIGluc3RydW1lbnRhdGlvbnMgdGhhdCBkbyBzbywgTVVTVCBhbHNvIHNldCBgaHR0cC5yZXF1ZXN0Lm1ldGhvZF9vcmlnaW5hbGAgdG8gdGhlIG9yaWdpbmFsIHZhbHVlLlxuICAgICovXG4gICAgSFRUUF9SRVFVRVNUX01FVEhPRDogJ2h0dHAucmVxdWVzdC5tZXRob2QnLFxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIEhUVFAgbWV0aG9kIHNlbnQgYnkgdGhlIGNsaWVudCBpbiB0aGUgcmVxdWVzdCBsaW5lLlxuICAgICAqL1xuICAgIEhUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUw6ICdodHRwLnJlcXVlc3QubWV0aG9kX29yaWdpbmFsJyxcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkaW5hbCBudW1iZXIgb2YgcmVxdWVzdCByZXNlbmRpbmcgYXR0ZW1wdCAoZm9yIGFueSByZWFzb24sIGluY2x1ZGluZyByZWRpcmVjdHMpLlxuICAgICAqXG4gICAgICogTm90ZTogVGhlIHJlc2VuZCBjb3VudCBTSE9VTEQgYmUgdXBkYXRlZCBlYWNoIHRpbWUgYW4gSFRUUCByZXF1ZXN0IGdldHMgcmVzZW50IGJ5IHRoZSBjbGllbnQsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB3YXMgdGhlIGNhdXNlIG9mIHRoZSByZXNlbmRpbmcgKGUuZy4gcmVkaXJlY3Rpb24sIGF1dGhvcml6YXRpb24gZmFpbHVyZSwgNTAzIFNlcnZlciBVbmF2YWlsYWJsZSwgbmV0d29yayBpc3N1ZXMsIG9yIGFueSBvdGhlcikuXG4gICAgICovXG4gICAgSFRUUF9SRVFVRVNUX1JFU0VORF9DT1VOVDogJ2h0dHAucmVxdWVzdC5yZXNlbmRfY291bnQnLFxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIHRoZSByZXNwb25zZSBwYXlsb2FkIGJvZHkgaW4gYnl0ZXMuIFRoaXMgaXMgdGhlIG51bWJlciBvZiBieXRlcyB0cmFuc2ZlcnJlZCBleGNsdWRpbmcgaGVhZGVycyBhbmQgaXMgb2Z0ZW4sIGJ1dCBub3QgYWx3YXlzLCBwcmVzZW50IGFzIHRoZSBbQ29udGVudC1MZW5ndGhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEwLmh0bWwjZmllbGQuY29udGVudC1sZW5ndGgpIGhlYWRlci4gRm9yIHJlcXVlc3RzIHVzaW5nIHRyYW5zcG9ydCBlbmNvZGluZywgdGhpcyBzaG91bGQgYmUgdGhlIGNvbXByZXNzZWQgc2l6ZS5cbiAgICAgKi9cbiAgICBIVFRQX1JFU1BPTlNFX0JPRFlfU0laRTogJ2h0dHAucmVzcG9uc2UuYm9keS5zaXplJyxcbiAgICAvKipcbiAgICAgKiBbSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZV0oaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02KS5cbiAgICAgKi9cbiAgICBIVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFOiAnaHR0cC5yZXNwb25zZS5zdGF0dXNfY29kZScsXG4gICAgLyoqXG4gICAgKiBUaGUgbWF0Y2hlZCByb3V0ZSwgdGhhdCBpcywgdGhlIHBhdGggdGVtcGxhdGUgaW4gdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZSByZXNwZWN0aXZlIHNlcnZlciBmcmFtZXdvcmsuXG4gICAgKlxuICAgICogTm90ZTogTVVTVCBOT1QgYmUgcG9wdWxhdGVkIHdoZW4gdGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBIVFRQIHNlcnZlciBmcmFtZXdvcmsgYXMgdGhlIHJvdXRlIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSBsb3ctY2FyZGluYWxpdHkgYW5kIHRoZSBVUkkgcGF0aCBjYW4gTk9UIHN1YnN0aXR1dGUgaXQuXG4gIFNIT1VMRCBpbmNsdWRlIHRoZSBbYXBwbGljYXRpb24gcm9vdF0oL2RvY3MvaHR0cC9odHRwLXNwYW5zLm1kI2h0dHAtc2VydmVyLWRlZmluaXRpb25zKSBpZiB0aGVyZSBpcyBvbmUuXG4gICAgKi9cbiAgICBIVFRQX1JPVVRFOiAnaHR0cC5yb3V0ZScsXG4gICAgLyoqXG4gICAgICogUGVlciBhZGRyZXNzIG9mIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24gLSBJUCBhZGRyZXNzIG9yIFVuaXggZG9tYWluIHNvY2tldCBuYW1lLlxuICAgICAqL1xuICAgIE5FVFdPUktfUEVFUl9BRERSRVNTOiAnbmV0d29yay5wZWVyLmFkZHJlc3MnLFxuICAgIC8qKlxuICAgICAqIFBlZXIgcG9ydCBudW1iZXIgb2YgdGhlIG5ldHdvcmsgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBORVRXT1JLX1BFRVJfUE9SVDogJ25ldHdvcmsucGVlci5wb3J0JyxcbiAgICAvKipcbiAgICAgKiBbT1NJIGFwcGxpY2F0aW9uIGxheWVyXShodHRwczovL29zaS1tb2RlbC5jb20vYXBwbGljYXRpb24tbGF5ZXIvKSBvciBub24tT1NJIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgdmFsdWUgU0hPVUxEIGJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlLlxuICAgICAqL1xuICAgIE5FVFdPUktfUFJPVE9DT0xfTkFNRTogJ25ldHdvcmsucHJvdG9jb2wubmFtZScsXG4gICAgLyoqXG4gICAgICogVmVyc2lvbiBvZiB0aGUgcHJvdG9jb2wgc3BlY2lmaWVkIGluIGBuZXR3b3JrLnByb3RvY29sLm5hbWVgLlxuICAgICAqXG4gICAgICogTm90ZTogYG5ldHdvcmsucHJvdG9jb2wudmVyc2lvbmAgcmVmZXJzIHRvIHRoZSB2ZXJzaW9uIG9mIHRoZSBwcm90b2NvbCB1c2VkIGFuZCBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgcHJvdG9jb2wgY2xpZW50JiMzOTtzIHZlcnNpb24uIElmIHRoZSBIVFRQIGNsaWVudCBoYXMgYSB2ZXJzaW9uIG9mIGAwLjI3LjJgLCBidXQgc2VuZHMgSFRUUCB2ZXJzaW9uIGAxLjFgLCB0aGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIGAxLjFgLlxuICAgICAqL1xuICAgIE5FVFdPUktfUFJPVE9DT0xfVkVSU0lPTjogJ25ldHdvcmsucHJvdG9jb2wudmVyc2lvbicsXG4gICAgLyoqXG4gICAgICogU2VydmVyIGRvbWFpbiBuYW1lIGlmIGF2YWlsYWJsZSB3aXRob3V0IHJldmVyc2UgRE5TIGxvb2t1cDsgb3RoZXJ3aXNlLCBJUCBhZGRyZXNzIG9yIFVuaXggZG9tYWluIHNvY2tldCBuYW1lLlxuICAgICAqXG4gICAgICogTm90ZTogV2hlbiBvYnNlcnZlZCBmcm9tIHRoZSBjbGllbnQgc2lkZSwgYW5kIHdoZW4gY29tbXVuaWNhdGluZyB0aHJvdWdoIGFuIGludGVybWVkaWFyeSwgYHNlcnZlci5hZGRyZXNzYCBTSE9VTEQgcmVwcmVzZW50IHRoZSBzZXJ2ZXIgYWRkcmVzcyBiZWhpbmQgYW55IGludGVybWVkaWFyaWVzLCBmb3IgZXhhbXBsZSBwcm94aWVzLCBpZiBpdCYjMzk7cyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgU0VSVkVSX0FERFJFU1M6ICdzZXJ2ZXIuYWRkcmVzcycsXG4gICAgLyoqXG4gICAgICogU2VydmVyIHBvcnQgbnVtYmVyLlxuICAgICAqXG4gICAgICogTm90ZTogV2hlbiBvYnNlcnZlZCBmcm9tIHRoZSBjbGllbnQgc2lkZSwgYW5kIHdoZW4gY29tbXVuaWNhdGluZyB0aHJvdWdoIGFuIGludGVybWVkaWFyeSwgYHNlcnZlci5wb3J0YCBTSE9VTEQgcmVwcmVzZW50IHRoZSBzZXJ2ZXIgcG9ydCBiZWhpbmQgYW55IGludGVybWVkaWFyaWVzLCBmb3IgZXhhbXBsZSBwcm94aWVzLCBpZiBpdCYjMzk7cyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgU0VSVkVSX1BPUlQ6ICdzZXJ2ZXIucG9ydCcsXG4gICAgLyoqXG4gICAgKiBBYnNvbHV0ZSBVUkwgZGVzY3JpYmluZyBhIG5ldHdvcmsgcmVzb3VyY2UgYWNjb3JkaW5nIHRvIFtSRkMzOTg2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NikuXG4gICAgKlxuICAgICogTm90ZTogRm9yIG5ldHdvcmsgY2FsbHMsIFVSTCB1c3VhbGx5IGhhcyBgc2NoZW1lOi8vaG9zdFs6cG9ydF1bcGF0aF1bP3F1ZXJ5XVsjZnJhZ21lbnRdYCBmb3JtYXQsIHdoZXJlIHRoZSBmcmFnbWVudCBpcyBub3QgdHJhbnNtaXR0ZWQgb3ZlciBIVFRQLCBidXQgaWYgaXQgaXMga25vd24sIGl0IFNIT1VMRCBiZSBpbmNsdWRlZCBuZXZlcnRoZWxlc3MuXG4gIGB1cmwuZnVsbGAgTVVTVCBOT1QgY29udGFpbiBjcmVkZW50aWFscyBwYXNzZWQgdmlhIFVSTCBpbiBmb3JtIG9mIGBodHRwczovL3VzZXJuYW1lOnBhc3N3b3JkQHd3dy5leGFtcGxlLmNvbS9gLiBJbiBzdWNoIGNhc2UgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIFNIT1VMRCBiZSByZWRhY3RlZCBhbmQgYXR0cmlidXRlJiMzOTtzIHZhbHVlIFNIT1VMRCBiZSBgaHR0cHM6Ly9SRURBQ1RFRDpSRURBQ1RFREB3d3cuZXhhbXBsZS5jb20vYC5cbiAgYHVybC5mdWxsYCBTSE9VTEQgY2FwdHVyZSB0aGUgYWJzb2x1dGUgVVJMIHdoZW4gaXQgaXMgYXZhaWxhYmxlIChvciBjYW4gYmUgcmVjb25zdHJ1Y3RlZCkgYW5kIFNIT1VMRCBOT1QgYmUgdmFsaWRhdGVkIG9yIG1vZGlmaWVkIGV4Y2VwdCBmb3Igc2FuaXRpemluZyBwdXJwb3Nlcy5cbiAgICAqL1xuICAgIFVSTF9GVUxMOiAndXJsLmZ1bGwnLFxuICAgIC8qKlxuICAgICAqIFRoZSBbVVJJIHBhdGhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMzOTg2I3NlY3Rpb24tMy4zKSBjb21wb25lbnQuXG4gICAgICovXG4gICAgVVJMX1BBVEg6ICd1cmwucGF0aCcsXG4gICAgLyoqXG4gICAgICogVGhlIFtVUkkgcXVlcnldKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMzOTg2I3NlY3Rpb24tMy40KSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBOb3RlOiBTZW5zaXRpdmUgY29udGVudCBwcm92aWRlZCBpbiBxdWVyeSBzdHJpbmcgU0hPVUxEIGJlIHNjcnViYmVkIHdoZW4gaW5zdHJ1bWVudGF0aW9ucyBjYW4gaWRlbnRpZnkgaXQuXG4gICAgICovXG4gICAgVVJMX1FVRVJZOiAndXJsLnF1ZXJ5JyxcbiAgICAvKipcbiAgICAgKiBUaGUgW1VSSSBzY2hlbWVdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmMzOTg2I3NlY3Rpb24tMy4xKSBjb21wb25lbnQgaWRlbnRpZnlpbmcgdGhlIHVzZWQgcHJvdG9jb2wuXG4gICAgICovXG4gICAgVVJMX1NDSEVNRTogJ3VybC5zY2hlbWUnLFxuICAgIC8qKlxuICAgICAqIFZhbHVlIG9mIHRoZSBbSFRUUCBVc2VyLUFnZW50XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMC5odG1sI2ZpZWxkLnVzZXItYWdlbnQpIGhlYWRlciBzZW50IGJ5IHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgVVNFUl9BR0VOVF9PUklHSU5BTDogJ3VzZXJfYWdlbnQub3JpZ2luYWwnLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlbWFudGljQXR0cmlidXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js":
/*!****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js ***!
  \****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\nvar undici_1 = __webpack_require__(/*! ./undici */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\");\nObject.defineProperty(exports, \"UndiciInstrumentation\", ({ enumerable: true, get: function () { return undici_1.UndiciInstrumentation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QixlQUFlLG1CQUFPLENBQUMsb01BQVU7QUFDakMseURBQXdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQzFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL2luZGV4LmpzPzBmOWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmRpY2lJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG52YXIgdW5kaWNpXzEgPSByZXF1aXJlKFwiLi91bmRpY2lcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmRpY2lJbnN0cnVtZW50YXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGljaV8xLlVuZGljaUluc3RydW1lbnRhdGlvbjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/index.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js ***!
  \*****************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst diagch = __webpack_require__(/*! diagnostics_channel */ \"diagnostics_channel\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.204.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\");\nconst SemanticAttributes_1 = __webpack_require__(/*! ./enums/SemanticAttributes */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/enums/SemanticAttributes.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass UndiciInstrumentation extends instrumentation_1.InstrumentationBase {\n    _recordFromReq = new WeakMap();\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, config);\n    }\n    // No need to instrument files/modules\n    init() {\n        return undefined;\n    }\n    disable() {\n        super.disable();\n        this._channelSubs.forEach(sub => sub.unsubscribe());\n        this._channelSubs.length = 0;\n    }\n    enable() {\n        // \"enabled\" handling is currently a bit messy with InstrumentationBase.\n        // If constructed with `{enabled: false}`, this `.enable()` is still called,\n        // and `this.getConfig().enabled !== this.isEnabled()`, creating confusion.\n        //\n        // For now, this class will setup for instrumenting if `.enable()` is\n        // called, but use `this.getConfig().enabled` to determine if\n        // instrumentation should be generated. This covers the more likely common\n        // case of config being given a construction time, rather than later via\n        // `instance.enable()`, `.disable()`, or `.setConfig()` calls.\n        super.enable();\n        // This method is called by the super-class constructor before ours is\n        // called. So we need to ensure the property is initalized.\n        this._channelSubs = this._channelSubs || [];\n        // Avoid to duplicate subscriptions\n        if (this._channelSubs.length > 0) {\n            return;\n        }\n        this.subscribeToChannel('undici:request:create', this.onRequestCreated.bind(this));\n        this.subscribeToChannel('undici:client:sendHeaders', this.onRequestHeaders.bind(this));\n        this.subscribeToChannel('undici:request:headers', this.onResponseHeaders.bind(this));\n        this.subscribeToChannel('undici:request:trailers', this.onDone.bind(this));\n        this.subscribeToChannel('undici:request:error', this.onError.bind(this));\n    }\n    _updateMetricInstruments() {\n        this._httpClientDurationHistogram = this.meter.createHistogram('http.client.request.duration', {\n            description: 'Measures the duration of outbound HTTP requests.',\n            unit: 's',\n            valueType: api_1.ValueType.DOUBLE,\n            advice: {\n                explicitBucketBoundaries: [\n                    0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5,\n                    7.5, 10,\n                ],\n            },\n        });\n    }\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        // `diagnostics_channel` had a ref counting bug until v18.19.0.\n        // https://github.com/nodejs/node/pull/47520\n        const [major, minor] = process.version\n            .replace('v', '')\n            .split('.')\n            .map(n => Number(n));\n        const useNewSubscribe = major > 18 || (major === 18 && minor >= 19);\n        let unsubscribe;\n        if (useNewSubscribe) {\n            diagch.subscribe?.(diagnosticChannel, onMessage);\n            unsubscribe = () => diagch.unsubscribe?.(diagnosticChannel, onMessage);\n        }\n        else {\n            const channel = diagch.channel(diagnosticChannel);\n            channel.subscribe(onMessage);\n            unsubscribe = () => channel.unsubscribe(onMessage);\n        }\n        this._channelSubs.push({\n            name: diagnosticChannel,\n            unsubscribe,\n        });\n    }\n    parseRequestHeaders(request) {\n        const result = new Map();\n        if (Array.isArray(request.headers)) {\n            // headers are an array [k1, v2, k2, v2] (undici v6+)\n            // values could be string or a string[] for multiple values\n            for (let i = 0; i < request.headers.length; i += 2) {\n                const key = request.headers[i];\n                const value = request.headers[i + 1];\n                // Key should always be a string, but the types don't know that, and let's be safe\n                if (typeof key === 'string') {\n                    result.set(key.toLowerCase(), value);\n                }\n            }\n        }\n        else if (typeof request.headers === 'string') {\n            // headers are a raw string (undici v5)\n            // headers could be repeated in several lines for multiple values\n            const headers = request.headers.split('\\r\\n');\n            for (const line of headers) {\n                if (!line) {\n                    continue;\n                }\n                const colonIndex = line.indexOf(':');\n                if (colonIndex === -1) {\n                    // Invalid header? Probably this can't happen, but again let's be safe.\n                    continue;\n                }\n                const key = line.substring(0, colonIndex).toLowerCase();\n                const value = line.substring(colonIndex + 1).trim();\n                const allValues = result.get(key);\n                if (allValues && Array.isArray(allValues)) {\n                    allValues.push(value);\n                }\n                else if (allValues) {\n                    result.set(key, [allValues, value]);\n                }\n                else {\n                    result.set(key, value);\n                }\n            }\n        }\n        return result;\n    }\n    // This is the 1st message we receive for each request (fired after request creation). Here we will\n    // create the span and populate some atttributes, then link the span to the request for further\n    // span processing\n    onRequestCreated({ request }) {\n        // Ignore if:\n        // - instrumentation is disabled\n        // - ignored by config\n        // - method is 'CONNECT'\n        const config = this.getConfig();\n        const enabled = config.enabled !== false;\n        const shouldIgnoreReq = (0, instrumentation_1.safeExecuteInTheMiddle)(() => !enabled ||\n            request.method === 'CONNECT' ||\n            config.ignoreRequestHook?.(request), e => e && this._diag.error('caught ignoreRequestHook error: ', e), true);\n        if (shouldIgnoreReq) {\n            return;\n        }\n        const startTime = (0, core_1.hrTime)();\n        let requestUrl;\n        try {\n            requestUrl = new url_1.URL(request.path, request.origin);\n        }\n        catch (err) {\n            this._diag.warn('could not determine url.full:', err);\n            // Skip instrumenting this request.\n            return;\n        }\n        const urlScheme = requestUrl.protocol.replace(':', '');\n        const requestMethod = this.getRequestMethod(request.method);\n        const attributes = {\n            [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD]: requestMethod,\n            [SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD_ORIGINAL]: request.method,\n            [SemanticAttributes_1.SemanticAttributes.URL_FULL]: requestUrl.toString(),\n            [SemanticAttributes_1.SemanticAttributes.URL_PATH]: requestUrl.pathname,\n            [SemanticAttributes_1.SemanticAttributes.URL_QUERY]: requestUrl.search,\n            [SemanticAttributes_1.SemanticAttributes.URL_SCHEME]: urlScheme,\n        };\n        const schemePorts = { https: '443', http: '80' };\n        const serverAddress = requestUrl.hostname;\n        const serverPort = requestUrl.port || schemePorts[urlScheme];\n        attributes[SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS] = serverAddress;\n        if (serverPort && !isNaN(Number(serverPort))) {\n            attributes[SemanticAttributes_1.SemanticAttributes.SERVER_PORT] = Number(serverPort);\n        }\n        // Get user agent from headers\n        const headersMap = this.parseRequestHeaders(request);\n        const userAgentValues = headersMap.get('user-agent');\n        if (userAgentValues) {\n            // NOTE: having multiple user agents is not expected so\n            // we're going to take last one like `curl` does\n            // ref: https://curl.se/docs/manpage.html#-A\n            const userAgent = Array.isArray(userAgentValues)\n                ? userAgentValues[userAgentValues.length - 1]\n                : userAgentValues;\n            attributes[SemanticAttributes_1.SemanticAttributes.USER_AGENT_ORIGINAL] = userAgent;\n        }\n        // Get attributes from the hook if present\n        const hookAttributes = (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.startSpanHook?.(request), e => e && this._diag.error('caught startSpanHook error: ', e), true);\n        if (hookAttributes) {\n            Object.entries(hookAttributes).forEach(([key, val]) => {\n                attributes[key] = val;\n            });\n        }\n        // Check if parent span is required via config and:\n        // - if a parent is required but not present, we use a `NoopSpan` to still\n        //   propagate context without recording it.\n        // - create a span otherwise\n        const activeCtx = api_1.context.active();\n        const currentSpan = api_1.trace.getSpan(activeCtx);\n        let span;\n        if (config.requireParentforSpans &&\n            (!currentSpan || !api_1.trace.isSpanContextValid(currentSpan.spanContext()))) {\n            span = api_1.trace.wrapSpanContext(api_1.INVALID_SPAN_CONTEXT);\n        }\n        else {\n            span = this.tracer.startSpan(requestMethod === '_OTHER' ? 'HTTP' : requestMethod, {\n                kind: api_1.SpanKind.CLIENT,\n                attributes: attributes,\n            }, activeCtx);\n        }\n        // Execute the request hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.requestHook?.(span, request), e => e && this._diag.error('caught requestHook error: ', e), true);\n        // Context propagation goes last so no hook can tamper\n        // the propagation headers\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        const headerEntries = Object.entries(addedHeaders);\n        for (let i = 0; i < headerEntries.length; i++) {\n            const [k, v] = headerEntries[i];\n            if (typeof request.addHeader === 'function') {\n                request.addHeader(k, v);\n            }\n            else if (typeof request.headers === 'string') {\n                request.headers += `${k}: ${v}\\r\\n`;\n            }\n            else if (Array.isArray(request.headers)) {\n                // undici@6.11.0 accidentally, briefly removed `request.addHeader()`.\n                request.headers.push(k, v);\n            }\n        }\n        this._recordFromReq.set(request, { span, attributes, startTime });\n    }\n    // This is the 2nd message we receive for each request. It is fired when connection with\n    // the remote is established and about to send the first byte. Here we do have info about the\n    // remote address and port so we can populate some `network.*` attributes into the span\n    onRequestHeaders({ request, socket }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const config = this.getConfig();\n        const { span } = record;\n        const { remoteAddress, remotePort } = socket;\n        const spanAttributes = {\n            [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_ADDRESS]: remoteAddress,\n            [SemanticAttributes_1.SemanticAttributes.NETWORK_PEER_PORT]: remotePort,\n        };\n        // After hooks have been processed (which may modify request headers)\n        // we can collect the headers based on the configuration\n        if (config.headersToSpanAttributes?.requestHeaders) {\n            const headersToAttribs = new Set(config.headersToSpanAttributes.requestHeaders.map(n => n.toLowerCase()));\n            const headersMap = this.parseRequestHeaders(request);\n            for (const [name, value] of headersMap.entries()) {\n                if (headersToAttribs.has(name)) {\n                    const attrValue = Array.isArray(value) ? value.join(', ') : value;\n                    spanAttributes[`http.request.header.${name}`] = attrValue;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n    }\n    // This is the 3rd message we get for each request and it's fired when the server\n    // headers are received, body may not be accessible yet.\n    // From the response headers we can set the status and content length\n    onResponseHeaders({ request, response, }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes } = record;\n        const spanAttributes = {\n            [SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE]: response.statusCode,\n        };\n        const config = this.getConfig();\n        // Execute the response hook if defined\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => config.responseHook?.(span, { request, response }), e => e && this._diag.error('caught responseHook error: ', e), true);\n        const headersToAttribs = new Set();\n        if (config.headersToSpanAttributes?.responseHeaders) {\n            config.headersToSpanAttributes?.responseHeaders.forEach(name => headersToAttribs.add(name.toLowerCase()));\n        }\n        for (let idx = 0; idx < response.headers.length; idx = idx + 2) {\n            const name = response.headers[idx].toString().toLowerCase();\n            const value = response.headers[idx + 1];\n            if (headersToAttribs.has(name)) {\n                spanAttributes[`http.response.header.${name}`] = value.toString();\n            }\n            if (name === 'content-length') {\n                const contentLength = Number(value.toString());\n                if (!isNaN(contentLength)) {\n                    spanAttributes['http.response.header.content-length'] = contentLength;\n                }\n            }\n        }\n        span.setAttributes(spanAttributes);\n        span.setStatus({\n            code: response.statusCode >= 400\n                ? api_1.SpanStatusCode.ERROR\n                : api_1.SpanStatusCode.UNSET,\n        });\n        record.attributes = Object.assign(attributes, spanAttributes);\n    }\n    // This is the last event we receive if the request went without any errors\n    onDone({ request }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // End the span\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics\n        this.recordRequestDuration(attributes, startTime);\n    }\n    // This is the event we get when something is wrong in the request like\n    // - invalid options when calling `fetch` global API or any undici method for request\n    // - connectivity errors such as unreachable host\n    // - requests aborted through an `AbortController.signal`\n    // NOTE: server errors are considered valid responses and it's the lib consumer\n    // who should deal with that.\n    onError({ request, error }) {\n        const record = this._recordFromReq.get(request);\n        if (!record) {\n            return;\n        }\n        const { span, attributes, startTime } = record;\n        // NOTE: in `undici@6.3.0` when request aborted the error type changes from\n        // a custom error (`RequestAbortedError`) to a built-in `DOMException` carrying\n        // some differences:\n        // - `code` is from DOMEXception (ABORT_ERR: 20)\n        // - `message` changes\n        // - stacktrace is smaller and contains node internal frames\n        span.recordException(error);\n        span.setStatus({\n            code: api_1.SpanStatusCode.ERROR,\n            message: error.message,\n        });\n        span.end();\n        this._recordFromReq.delete(request);\n        // Record metrics (with the error)\n        attributes[SemanticAttributes_1.SemanticAttributes.ERROR_TYPE] = error.message;\n        this.recordRequestDuration(attributes, startTime);\n    }\n    recordRequestDuration(attributes, startTime) {\n        // Time to record metrics\n        const metricsAttributes = {};\n        // Get the attribs already in span attributes\n        const keysToCopy = [\n            SemanticAttributes_1.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE,\n            SemanticAttributes_1.SemanticAttributes.HTTP_REQUEST_METHOD,\n            SemanticAttributes_1.SemanticAttributes.SERVER_ADDRESS,\n            SemanticAttributes_1.SemanticAttributes.SERVER_PORT,\n            SemanticAttributes_1.SemanticAttributes.URL_SCHEME,\n            SemanticAttributes_1.SemanticAttributes.ERROR_TYPE,\n        ];\n        keysToCopy.forEach(key => {\n            if (key in attributes) {\n                metricsAttributes[key] = attributes[key];\n            }\n        });\n        // Take the duration and record it\n        const durationSeconds = (0, core_1.hrTimeToMilliseconds)((0, core_1.hrTimeDuration)(startTime, (0, core_1.hrTime)())) / 1000;\n        this._httpClientDurationHistogram.record(durationSeconds, metricsAttributes);\n    }\n    getRequestMethod(original) {\n        const knownMethods = {\n            CONNECT: true,\n            OPTIONS: true,\n            HEAD: true,\n            GET: true,\n            POST: true,\n            PUT: true,\n            PATCH: true,\n            DELETE: true,\n            TRACE: true,\n        };\n        if (original.toUpperCase() in knownMethods) {\n            return original.toUpperCase();\n        }\n        return '_OTHER';\n    }\n}\nexports.UndiciInstrumentation = UndiciInstrumentation;\n//# sourceMappingURL=undici.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3VuZGljaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGdEQUFxQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsNE1BQWdDO0FBQ2xFLGNBQWMsbUJBQU8sQ0FBQyw2SUFBb0I7QUFDMUM7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzTUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyx3T0FBNEI7QUFDakUsZUFBZSxtQkFBTyxDQUFDLHlLQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLElBQUksRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNkJBQTZCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixtQkFBbUI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4QkFBOEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3VuZGljaS5qcz8xZjRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VbmRpY2lJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZGlhZ2NoID0gcmVxdWlyZShcImRpYWdub3N0aWNzX2NoYW5uZWxcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG4vKiogQGtuaXBpZ25vcmUgKi9cbmNvbnN0IHZlcnNpb25fMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb25cIik7XG5jb25zdCBTZW1hbnRpY0F0dHJpYnV0ZXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zL1NlbWFudGljQXR0cmlidXRlc1wiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9jb3JlXCIpO1xuLy8gQSBjb21iaW5hdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9hcG0tYWdlbnQtbm9kZWpzIGFuZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZGdldC1pbmMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb25zL2Jsb2IvbWFpbi9wYWNrYWdlcy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbi11bmRpY2kvc3JjL2luZGV4LnRzXG5jbGFzcyBVbmRpY2lJbnN0cnVtZW50YXRpb24gZXh0ZW5kcyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25CYXNlIHtcbiAgICBfcmVjb3JkRnJvbVJlcSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIodmVyc2lvbl8xLlBBQ0tBR0VfTkFNRSwgdmVyc2lvbl8xLlBBQ0tBR0VfVkVSU0lPTiwgY29uZmlnKTtcbiAgICB9XG4gICAgLy8gTm8gbmVlZCB0byBpbnN0cnVtZW50IGZpbGVzL21vZHVsZXNcbiAgICBpbml0KCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICBzdXBlci5kaXNhYmxlKCk7XG4gICAgICAgIHRoaXMuX2NoYW5uZWxTdWJzLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5fY2hhbm5lbFN1YnMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICAvLyBcImVuYWJsZWRcIiBoYW5kbGluZyBpcyBjdXJyZW50bHkgYSBiaXQgbWVzc3kgd2l0aCBJbnN0cnVtZW50YXRpb25CYXNlLlxuICAgICAgICAvLyBJZiBjb25zdHJ1Y3RlZCB3aXRoIGB7ZW5hYmxlZDogZmFsc2V9YCwgdGhpcyBgLmVuYWJsZSgpYCBpcyBzdGlsbCBjYWxsZWQsXG4gICAgICAgIC8vIGFuZCBgdGhpcy5nZXRDb25maWcoKS5lbmFibGVkICE9PSB0aGlzLmlzRW5hYmxlZCgpYCwgY3JlYXRpbmcgY29uZnVzaW9uLlxuICAgICAgICAvL1xuICAgICAgICAvLyBGb3Igbm93LCB0aGlzIGNsYXNzIHdpbGwgc2V0dXAgZm9yIGluc3RydW1lbnRpbmcgaWYgYC5lbmFibGUoKWAgaXNcbiAgICAgICAgLy8gY2FsbGVkLCBidXQgdXNlIGB0aGlzLmdldENvbmZpZygpLmVuYWJsZWRgIHRvIGRldGVybWluZSBpZlxuICAgICAgICAvLyBpbnN0cnVtZW50YXRpb24gc2hvdWxkIGJlIGdlbmVyYXRlZC4gVGhpcyBjb3ZlcnMgdGhlIG1vcmUgbGlrZWx5IGNvbW1vblxuICAgICAgICAvLyBjYXNlIG9mIGNvbmZpZyBiZWluZyBnaXZlbiBhIGNvbnN0cnVjdGlvbiB0aW1lLCByYXRoZXIgdGhhbiBsYXRlciB2aWFcbiAgICAgICAgLy8gYGluc3RhbmNlLmVuYWJsZSgpYCwgYC5kaXNhYmxlKClgLCBvciBgLnNldENvbmZpZygpYCBjYWxscy5cbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgc3VwZXItY2xhc3MgY29uc3RydWN0b3IgYmVmb3JlIG91cnMgaXNcbiAgICAgICAgLy8gY2FsbGVkLiBTbyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgcHJvcGVydHkgaXMgaW5pdGFsaXplZC5cbiAgICAgICAgdGhpcy5fY2hhbm5lbFN1YnMgPSB0aGlzLl9jaGFubmVsU3VicyB8fCBbXTtcbiAgICAgICAgLy8gQXZvaWQgdG8gZHVwbGljYXRlIHN1YnNjcmlwdGlvbnNcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5uZWxTdWJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6Y3JlYXRlJywgdGhpcy5vblJlcXVlc3RDcmVhdGVkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycsIHRoaXMub25SZXF1ZXN0SGVhZGVycy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmhlYWRlcnMnLCB0aGlzLm9uUmVzcG9uc2VIZWFkZXJzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6dHJhaWxlcnMnLCB0aGlzLm9uRG9uZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJywgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBfdXBkYXRlTWV0cmljSW5zdHJ1bWVudHMoKSB7XG4gICAgICAgIHRoaXMuX2h0dHBDbGllbnREdXJhdGlvbkhpc3RvZ3JhbSA9IHRoaXMubWV0ZXIuY3JlYXRlSGlzdG9ncmFtKCdodHRwLmNsaWVudC5yZXF1ZXN0LmR1cmF0aW9uJywge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdNZWFzdXJlcyB0aGUgZHVyYXRpb24gb2Ygb3V0Ym91bmQgSFRUUCByZXF1ZXN0cy4nLFxuICAgICAgICAgICAgdW5pdDogJ3MnLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBhcGlfMS5WYWx1ZVR5cGUuRE9VQkxFLFxuICAgICAgICAgICAgYWR2aWNlOiB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXRCdWNrZXRCb3VuZGFyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgIDAuMDA1LCAwLjAxLCAwLjAyNSwgMC4wNSwgMC4wNzUsIDAuMSwgMC4yNSwgMC41LCAwLjc1LCAxLCAyLjUsIDUsXG4gICAgICAgICAgICAgICAgICAgIDcuNSwgMTAsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0NoYW5uZWwoZGlhZ25vc3RpY0NoYW5uZWwsIG9uTWVzc2FnZSkge1xuICAgICAgICAvLyBgZGlhZ25vc3RpY3NfY2hhbm5lbGAgaGFkIGEgcmVmIGNvdW50aW5nIGJ1ZyB1bnRpbCB2MTguMTkuMC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL3B1bGwvNDc1MjBcbiAgICAgICAgY29uc3QgW21ham9yLCBtaW5vcl0gPSBwcm9jZXNzLnZlcnNpb25cbiAgICAgICAgICAgIC5yZXBsYWNlKCd2JywgJycpXG4gICAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICAgICAgLm1hcChuID0+IE51bWJlcihuKSk7XG4gICAgICAgIGNvbnN0IHVzZU5ld1N1YnNjcmliZSA9IG1ham9yID4gMTggfHwgKG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAxOSk7XG4gICAgICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICAgICAgaWYgKHVzZU5ld1N1YnNjcmliZSkge1xuICAgICAgICAgICAgZGlhZ2NoLnN1YnNjcmliZT8uKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBkaWFnY2gudW5zdWJzY3JpYmU/LihkaWFnbm9zdGljQ2hhbm5lbCwgb25NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBkaWFnY2guY2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCk7XG4gICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZShvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbm5lbFN1YnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkaWFnbm9zdGljQ2hhbm5lbCxcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxdWVzdC5oZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gaGVhZGVycyBhcmUgYW4gYXJyYXkgW2sxLCB2MiwgazIsIHYyXSAodW5kaWNpIHY2KylcbiAgICAgICAgICAgIC8vIHZhbHVlcyBjb3VsZCBiZSBzdHJpbmcgb3IgYSBzdHJpbmdbXSBmb3IgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3QuaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHJlcXVlc3QuaGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlcXVlc3QuaGVhZGVyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgLy8gS2V5IHNob3VsZCBhbHdheXMgYmUgYSBzdHJpbmcsIGJ1dCB0aGUgdHlwZXMgZG9uJ3Qga25vdyB0aGF0LCBhbmQgbGV0J3MgYmUgc2FmZVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleS50b0xvd2VyQ2FzZSgpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXJzIGFyZSBhIHJhdyBzdHJpbmcgKHVuZGljaSB2NSlcbiAgICAgICAgICAgIC8vIGhlYWRlcnMgY291bGQgYmUgcmVwZWF0ZWQgaW4gc2V2ZXJhbCBsaW5lcyBmb3IgbXVsdGlwbGUgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvbkluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgaGVhZGVyPyBQcm9iYWJseSB0aGlzIGNhbid0IGhhcHBlbiwgYnV0IGFnYWluIGxldCdzIGJlIHNhZmUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBsaW5lLnN1YnN0cmluZygwLCBjb2xvbkluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zdWJzdHJpbmcoY29sb25JbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxWYWx1ZXMgPSByZXN1bHQuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFZhbHVlcyAmJiBBcnJheS5pc0FycmF5KGFsbFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChrZXksIFthbGxWYWx1ZXMsIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSAxc3QgbWVzc2FnZSB3ZSByZWNlaXZlIGZvciBlYWNoIHJlcXVlc3QgKGZpcmVkIGFmdGVyIHJlcXVlc3QgY3JlYXRpb24pLiBIZXJlIHdlIHdpbGxcbiAgICAvLyBjcmVhdGUgdGhlIHNwYW4gYW5kIHBvcHVsYXRlIHNvbWUgYXR0dHJpYnV0ZXMsIHRoZW4gbGluayB0aGUgc3BhbiB0byB0aGUgcmVxdWVzdCBmb3IgZnVydGhlclxuICAgIC8vIHNwYW4gcHJvY2Vzc2luZ1xuICAgIG9uUmVxdWVzdENyZWF0ZWQoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgLy8gSWdub3JlIGlmOlxuICAgICAgICAvLyAtIGluc3RydW1lbnRhdGlvbiBpcyBkaXNhYmxlZFxuICAgICAgICAvLyAtIGlnbm9yZWQgYnkgY29uZmlnXG4gICAgICAgIC8vIC0gbWV0aG9kIGlzICdDT05ORUNUJ1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBjb25zdCBlbmFibGVkID0gY29uZmlnLmVuYWJsZWQgIT09IGZhbHNlO1xuICAgICAgICBjb25zdCBzaG91bGRJZ25vcmVSZXEgPSAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gIWVuYWJsZWQgfHxcbiAgICAgICAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vaz8uKHJlcXVlc3QpLCBlID0+IGUgJiYgdGhpcy5fZGlhZy5lcnJvcignY2F1Z2h0IGlnbm9yZVJlcXVlc3RIb29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVSZXEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSAoMCwgY29yZV8xLmhyVGltZSkoKTtcbiAgICAgICAgbGV0IHJlcXVlc3RVcmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXF1ZXN0VXJsID0gbmV3IHVybF8xLlVSTChyZXF1ZXN0LnBhdGgsIHJlcXVlc3Qub3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kaWFnLndhcm4oJ2NvdWxkIG5vdCBkZXRlcm1pbmUgdXJsLmZ1bGw6JywgZXJyKTtcbiAgICAgICAgICAgIC8vIFNraXAgaW5zdHJ1bWVudGluZyB0aGlzIHJlcXVlc3QuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsU2NoZW1lID0gcmVxdWVzdFVybC5wcm90b2NvbC5yZXBsYWNlKCc6JywgJycpO1xuICAgICAgICBjb25zdCByZXF1ZXN0TWV0aG9kID0gdGhpcy5nZXRSZXF1ZXN0TWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9SRVFVRVNUX01FVEhPRF06IHJlcXVlc3RNZXRob2QsXG4gICAgICAgICAgICBbU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfUkVRVUVTVF9NRVRIT0RfT1JJR0lOQUxdOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuVVJMX0ZVTExdOiByZXF1ZXN0VXJsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBbU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlVSTF9QQVRIXTogcmVxdWVzdFVybC5wYXRobmFtZSxcbiAgICAgICAgICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuVVJMX1FVRVJZXTogcmVxdWVzdFVybC5zZWFyY2gsXG4gICAgICAgICAgICBbU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlVSTF9TQ0hFTUVdOiB1cmxTY2hlbWUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNjaGVtZVBvcnRzID0geyBodHRwczogJzQ0MycsIGh0dHA6ICc4MCcgfTtcbiAgICAgICAgY29uc3Qgc2VydmVyQWRkcmVzcyA9IHJlcXVlc3RVcmwuaG9zdG5hbWU7XG4gICAgICAgIGNvbnN0IHNlcnZlclBvcnQgPSByZXF1ZXN0VXJsLnBvcnQgfHwgc2NoZW1lUG9ydHNbdXJsU2NoZW1lXTtcbiAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuU0VSVkVSX0FERFJFU1NdID0gc2VydmVyQWRkcmVzcztcbiAgICAgICAgaWYgKHNlcnZlclBvcnQgJiYgIWlzTmFOKE51bWJlcihzZXJ2ZXJQb3J0KSkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlNFUlZFUl9QT1JUXSA9IE51bWJlcihzZXJ2ZXJQb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdXNlciBhZ2VudCBmcm9tIGhlYWRlcnNcbiAgICAgICAgY29uc3QgaGVhZGVyc01hcCA9IHRoaXMucGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXNlckFnZW50VmFsdWVzID0gaGVhZGVyc01hcC5nZXQoJ3VzZXItYWdlbnQnKTtcbiAgICAgICAgaWYgKHVzZXJBZ2VudFZhbHVlcykge1xuICAgICAgICAgICAgLy8gTk9URTogaGF2aW5nIG11bHRpcGxlIHVzZXIgYWdlbnRzIGlzIG5vdCBleHBlY3RlZCBzb1xuICAgICAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gdGFrZSBsYXN0IG9uZSBsaWtlIGBjdXJsYCBkb2VzXG4gICAgICAgICAgICAvLyByZWY6IGh0dHBzOi8vY3VybC5zZS9kb2NzL21hbnBhZ2UuaHRtbCMtQVxuICAgICAgICAgICAgY29uc3QgdXNlckFnZW50ID0gQXJyYXkuaXNBcnJheSh1c2VyQWdlbnRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgPyB1c2VyQWdlbnRWYWx1ZXNbdXNlckFnZW50VmFsdWVzLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgOiB1c2VyQWdlbnRWYWx1ZXM7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW1NlbWFudGljQXR0cmlidXRlc18xLlNlbWFudGljQXR0cmlidXRlcy5VU0VSX0FHRU5UX09SSUdJTkFMXSA9IHVzZXJBZ2VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYXR0cmlidXRlcyBmcm9tIHRoZSBob29rIGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgaG9va0F0dHJpYnV0ZXMgPSAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uZmlnLnN0YXJ0U3Bhbkhvb2s/LihyZXF1ZXN0KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCBzdGFydFNwYW5Ib29rIGVycm9yOiAnLCBlKSwgdHJ1ZSk7XG4gICAgICAgIGlmIChob29rQXR0cmlidXRlcykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaG9va0F0dHJpYnV0ZXMpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBwYXJlbnQgc3BhbiBpcyByZXF1aXJlZCB2aWEgY29uZmlnIGFuZDpcbiAgICAgICAgLy8gLSBpZiBhIHBhcmVudCBpcyByZXF1aXJlZCBidXQgbm90IHByZXNlbnQsIHdlIHVzZSBhIGBOb29wU3BhbmAgdG8gc3RpbGxcbiAgICAgICAgLy8gICBwcm9wYWdhdGUgY29udGV4dCB3aXRob3V0IHJlY29yZGluZyBpdC5cbiAgICAgICAgLy8gLSBjcmVhdGUgYSBzcGFuIG90aGVyd2lzZVxuICAgICAgICBjb25zdCBhY3RpdmVDdHggPSBhcGlfMS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IGFwaV8xLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICAgICAgbGV0IHNwYW47XG4gICAgICAgIGlmIChjb25maWcucmVxdWlyZVBhcmVudGZvclNwYW5zICYmXG4gICAgICAgICAgICAoIWN1cnJlbnRTcGFuIHx8ICFhcGlfMS50cmFjZS5pc1NwYW5Db250ZXh0VmFsaWQoY3VycmVudFNwYW4uc3BhbkNvbnRleHQoKSkpKSB7XG4gICAgICAgICAgICBzcGFuID0gYXBpXzEudHJhY2Uud3JhcFNwYW5Db250ZXh0KGFwaV8xLklOVkFMSURfU1BBTl9DT05URVhUKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4ocmVxdWVzdE1ldGhvZCA9PT0gJ19PVEhFUicgPyAnSFRUUCcgOiByZXF1ZXN0TWV0aG9kLCB7XG4gICAgICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ0xJRU5ULFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9LCBhY3RpdmVDdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIHJlcXVlc3QgaG9vayBpZiBkZWZpbmVkXG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcucmVxdWVzdEhvb2s/LihzcGFuLCByZXF1ZXN0KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCByZXF1ZXN0SG9vayBlcnJvcjogJywgZSksIHRydWUpO1xuICAgICAgICAvLyBDb250ZXh0IHByb3BhZ2F0aW9uIGdvZXMgbGFzdCBzbyBubyBob29rIGNhbiB0YW1wZXJcbiAgICAgICAgLy8gdGhlIHByb3BhZ2F0aW9uIGhlYWRlcnNcbiAgICAgICAgY29uc3QgcmVxdWVzdENvbnRleHQgPSBhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pO1xuICAgICAgICBjb25zdCBhZGRlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBhZGRlZEhlYWRlcnMpO1xuICAgICAgICBjb25zdCBoZWFkZXJFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYWRkZWRIZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBbaywgdl0gPSBoZWFkZXJFbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0LmFkZEhlYWRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWRkSGVhZGVyKGssIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMgKz0gYCR7a306ICR7dn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgLy8gdW5kaWNpQDYuMTEuMCBhY2NpZGVudGFsbHksIGJyaWVmbHkgcmVtb3ZlZCBgcmVxdWVzdC5hZGRIZWFkZXIoKWAuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLnB1c2goaywgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5zZXQocmVxdWVzdCwgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIDJuZCBtZXNzYWdlIHdlIHJlY2VpdmUgZm9yIGVhY2ggcmVxdWVzdC4gSXQgaXMgZmlyZWQgd2hlbiBjb25uZWN0aW9uIHdpdGhcbiAgICAvLyB0aGUgcmVtb3RlIGlzIGVzdGFibGlzaGVkIGFuZCBhYm91dCB0byBzZW5kIHRoZSBmaXJzdCBieXRlLiBIZXJlIHdlIGRvIGhhdmUgaW5mbyBhYm91dCB0aGVcbiAgICAvLyByZW1vdGUgYWRkcmVzcyBhbmQgcG9ydCBzbyB3ZSBjYW4gcG9wdWxhdGUgc29tZSBgbmV0d29yay4qYCBhdHRyaWJ1dGVzIGludG8gdGhlIHNwYW5cbiAgICBvblJlcXVlc3RIZWFkZXJzKHsgcmVxdWVzdCwgc29ja2V0IH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgY29uc3QgeyBzcGFuIH0gPSByZWNvcmQ7XG4gICAgICAgIGNvbnN0IHsgcmVtb3RlQWRkcmVzcywgcmVtb3RlUG9ydCB9ID0gc29ja2V0O1xuICAgICAgICBjb25zdCBzcGFuQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgIFtTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuTkVUV09SS19QRUVSX0FERFJFU1NdOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgW1NlbWFudGljQXR0cmlidXRlc18xLlNlbWFudGljQXR0cmlidXRlcy5ORVRXT1JLX1BFRVJfUE9SVF06IHJlbW90ZVBvcnQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFmdGVyIGhvb2tzIGhhdmUgYmVlbiBwcm9jZXNzZWQgKHdoaWNoIG1heSBtb2RpZnkgcmVxdWVzdCBoZWFkZXJzKVxuICAgICAgICAvLyB3ZSBjYW4gY29sbGVjdCB0aGUgaGVhZGVycyBiYXNlZCBvbiB0aGUgY29uZmlndXJhdGlvblxuICAgICAgICBpZiAoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzPy5yZXF1ZXN0SGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyc1RvQXR0cmlicyA9IG5ldyBTZXQoY29uZmlnLmhlYWRlcnNUb1NwYW5BdHRyaWJ1dGVzLnJlcXVlc3RIZWFkZXJzLm1hcChuID0+IG4udG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyc01hcCA9IHRoaXMucGFyc2VSZXF1ZXN0SGVhZGVycyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBoZWFkZXJzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzVG9BdHRyaWJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyVmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmpvaW4oJywgJykgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbYGh0dHAucmVxdWVzdC5oZWFkZXIuJHtuYW1lfWBdID0gYXR0clZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoc3BhbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSAzcmQgbWVzc2FnZSB3ZSBnZXQgZm9yIGVhY2ggcmVxdWVzdCBhbmQgaXQncyBmaXJlZCB3aGVuIHRoZSBzZXJ2ZXJcbiAgICAvLyBoZWFkZXJzIGFyZSByZWNlaXZlZCwgYm9keSBtYXkgbm90IGJlIGFjY2Vzc2libGUgeWV0LlxuICAgIC8vIEZyb20gdGhlIHJlc3BvbnNlIGhlYWRlcnMgd2UgY2FuIHNldCB0aGUgc3RhdHVzIGFuZCBjb250ZW50IGxlbmd0aFxuICAgIG9uUmVzcG9uc2VIZWFkZXJzKHsgcmVxdWVzdCwgcmVzcG9uc2UsIH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzIH0gPSByZWNvcmQ7XG4gICAgICAgIGNvbnN0IHNwYW5BdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgW1NlbWFudGljQXR0cmlidXRlc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFU1BPTlNFX1NUQVRVU19DT0RFXTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgcmVzcG9uc2UgaG9vayBpZiBkZWZpbmVkXG4gICAgICAgICgwLCBpbnN0cnVtZW50YXRpb25fMS5zYWZlRXhlY3V0ZUluVGhlTWlkZGxlKSgoKSA9PiBjb25maWcucmVzcG9uc2VIb29rPy4oc3BhbiwgeyByZXF1ZXN0LCByZXNwb25zZSB9KSwgZSA9PiBlICYmIHRoaXMuX2RpYWcuZXJyb3IoJ2NhdWdodCByZXNwb25zZUhvb2sgZXJyb3I6ICcsIGUpLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaGVhZGVyc1RvQXR0cmlicyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5oZWFkZXJzVG9TcGFuQXR0cmlidXRlcz8ucmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25maWcuaGVhZGVyc1RvU3BhbkF0dHJpYnV0ZXM/LnJlc3BvbnNlSGVhZGVycy5mb3JFYWNoKG5hbWUgPT4gaGVhZGVyc1RvQXR0cmlicy5hZGQobmFtZS50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcmVzcG9uc2UuaGVhZGVycy5sZW5ndGg7IGlkeCA9IGlkeCArIDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSByZXNwb25zZS5oZWFkZXJzW2lkeF0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXNwb25zZS5oZWFkZXJzW2lkeCArIDFdO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNUb0F0dHJpYnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc3BhbkF0dHJpYnV0ZXNbYGh0dHAucmVzcG9uc2UuaGVhZGVyLiR7bmFtZX1gXSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBOdW1iZXIodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihjb250ZW50TGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuQXR0cmlidXRlc1snaHR0cC5yZXNwb25zZS5oZWFkZXIuY29udGVudC1sZW5ndGgnXSA9IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhzcGFuQXR0cmlidXRlcyk7XG4gICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwXG4gICAgICAgICAgICAgICAgPyBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUlxuICAgICAgICAgICAgICAgIDogYXBpXzEuU3BhblN0YXR1c0NvZGUuVU5TRVQsXG4gICAgICAgIH0pO1xuICAgICAgICByZWNvcmQuYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgc3BhbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGV2ZW50IHdlIHJlY2VpdmUgaWYgdGhlIHJlcXVlc3Qgd2VudCB3aXRob3V0IGFueSBlcnJvcnNcbiAgICBvbkRvbmUoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSA9IHJlY29yZDtcbiAgICAgICAgLy8gRW5kIHRoZSBzcGFuXG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIHRoaXMuX3JlY29yZEZyb21SZXEuZGVsZXRlKHJlcXVlc3QpO1xuICAgICAgICAvLyBSZWNvcmQgbWV0cmljc1xuICAgICAgICB0aGlzLnJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHRoZSBldmVudCB3ZSBnZXQgd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcgaW4gdGhlIHJlcXVlc3QgbGlrZVxuICAgIC8vIC0gaW52YWxpZCBvcHRpb25zIHdoZW4gY2FsbGluZyBgZmV0Y2hgIGdsb2JhbCBBUEkgb3IgYW55IHVuZGljaSBtZXRob2QgZm9yIHJlcXVlc3RcbiAgICAvLyAtIGNvbm5lY3Rpdml0eSBlcnJvcnMgc3VjaCBhcyB1bnJlYWNoYWJsZSBob3N0XG4gICAgLy8gLSByZXF1ZXN0cyBhYm9ydGVkIHRocm91Z2ggYW4gYEFib3J0Q29udHJvbGxlci5zaWduYWxgXG4gICAgLy8gTk9URTogc2VydmVyIGVycm9ycyBhcmUgY29uc2lkZXJlZCB2YWxpZCByZXNwb25zZXMgYW5kIGl0J3MgdGhlIGxpYiBjb25zdW1lclxuICAgIC8vIHdobyBzaG91bGQgZGVhbCB3aXRoIHRoYXQuXG4gICAgb25FcnJvcih7IHJlcXVlc3QsIGVycm9yIH0pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gdGhpcy5fcmVjb3JkRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzcGFuLCBhdHRyaWJ1dGVzLCBzdGFydFRpbWUgfSA9IHJlY29yZDtcbiAgICAgICAgLy8gTk9URTogaW4gYHVuZGljaUA2LjMuMGAgd2hlbiByZXF1ZXN0IGFib3J0ZWQgdGhlIGVycm9yIHR5cGUgY2hhbmdlcyBmcm9tXG4gICAgICAgIC8vIGEgY3VzdG9tIGVycm9yIChgUmVxdWVzdEFib3J0ZWRFcnJvcmApIHRvIGEgYnVpbHQtaW4gYERPTUV4Y2VwdGlvbmAgY2FycnlpbmdcbiAgICAgICAgLy8gc29tZSBkaWZmZXJlbmNlczpcbiAgICAgICAgLy8gLSBgY29kZWAgaXMgZnJvbSBET01FWGNlcHRpb24gKEFCT1JUX0VSUjogMjApXG4gICAgICAgIC8vIC0gYG1lc3NhZ2VgIGNoYW5nZXNcbiAgICAgICAgLy8gLSBzdGFja3RyYWNlIGlzIHNtYWxsZXIgYW5kIGNvbnRhaW5zIG5vZGUgaW50ZXJuYWwgZnJhbWVzXG4gICAgICAgIHNwYW4ucmVjb3JkRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgdGhpcy5fcmVjb3JkRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIC8vIFJlY29yZCBtZXRyaWNzICh3aXRoIHRoZSBlcnJvcilcbiAgICAgICAgYXR0cmlidXRlc1tTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuRVJST1JfVFlQRV0gPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICB0aGlzLnJlY29yZFJlcXVlc3REdXJhdGlvbihhdHRyaWJ1dGVzLCBzdGFydFRpbWUpO1xuICAgIH1cbiAgICByZWNvcmRSZXF1ZXN0RHVyYXRpb24oYXR0cmlidXRlcywgc3RhcnRUaW1lKSB7XG4gICAgICAgIC8vIFRpbWUgdG8gcmVjb3JkIG1ldHJpY3NcbiAgICAgICAgY29uc3QgbWV0cmljc0F0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgLy8gR2V0IHRoZSBhdHRyaWJzIGFscmVhZHkgaW4gc3BhbiBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGtleXNUb0NvcHkgPSBbXG4gICAgICAgICAgICBTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9SRVNQT05TRV9TVEFUVVNfQ09ERSxcbiAgICAgICAgICAgIFNlbWFudGljQXR0cmlidXRlc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFUVVFU1RfTUVUSE9ELFxuICAgICAgICAgICAgU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlNFUlZFUl9BRERSRVNTLFxuICAgICAgICAgICAgU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlNFUlZFUl9QT1JULFxuICAgICAgICAgICAgU2VtYW50aWNBdHRyaWJ1dGVzXzEuU2VtYW50aWNBdHRyaWJ1dGVzLlVSTF9TQ0hFTUUsXG4gICAgICAgICAgICBTZW1hbnRpY0F0dHJpYnV0ZXNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuRVJST1JfVFlQRSxcbiAgICAgICAgXTtcbiAgICAgICAga2V5c1RvQ29weS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzQXR0cmlidXRlc1trZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGFrZSB0aGUgZHVyYXRpb24gYW5kIHJlY29yZCBpdFxuICAgICAgICBjb25zdCBkdXJhdGlvblNlY29uZHMgPSAoMCwgY29yZV8xLmhyVGltZVRvTWlsbGlzZWNvbmRzKSgoMCwgY29yZV8xLmhyVGltZUR1cmF0aW9uKShzdGFydFRpbWUsICgwLCBjb3JlXzEuaHJUaW1lKSgpKSkgLyAxMDAwO1xuICAgICAgICB0aGlzLl9odHRwQ2xpZW50RHVyYXRpb25IaXN0b2dyYW0ucmVjb3JkKGR1cmF0aW9uU2Vjb25kcywgbWV0cmljc0F0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0TWV0aG9kKG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IGtub3duTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIENPTk5FQ1Q6IHRydWUsXG4gICAgICAgICAgICBPUFRJT05TOiB0cnVlLFxuICAgICAgICAgICAgSEVBRDogdHJ1ZSxcbiAgICAgICAgICAgIEdFVDogdHJ1ZSxcbiAgICAgICAgICAgIFBPU1Q6IHRydWUsXG4gICAgICAgICAgICBQVVQ6IHRydWUsXG4gICAgICAgICAgICBQQVRDSDogdHJ1ZSxcbiAgICAgICAgICAgIERFTEVURTogdHJ1ZSxcbiAgICAgICAgICAgIFRSQUNFOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3JpZ2luYWwudG9VcHBlckNhc2UoKSBpbiBrbm93bk1ldGhvZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnX09USEVSJztcbiAgICB9XG59XG5leHBvcnRzLlVuZGljaUluc3RydW1lbnRhdGlvbiA9IFVuZGljaUluc3RydW1lbnRhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuZGljaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/undici.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.15.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-undici';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tdW5kaWNpQDAuMTUuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2kvYnVpbGQvc3JjL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzlDO0FBQ0EsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLXVuZGljaUAwLjE1LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tdW5kaWNpL2J1aWxkL3NyYy92ZXJzaW9uLmpzPzA5YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQUNLQUdFX05BTUUgPSBleHBvcnRzLlBBQ0tBR0VfVkVSU0lPTiA9IHZvaWQgMDtcbi8vIHRoaXMgaXMgYXV0b2dlbmVyYXRlZCBmaWxlLCBzZWUgc2NyaXB0cy92ZXJzaW9uLXVwZGF0ZS5qc1xuZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSAnMC4xNS4wJztcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi11bmRpY2knO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-undici@0.15.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-undici/build/src/version.js\n");

/***/ })

};
;