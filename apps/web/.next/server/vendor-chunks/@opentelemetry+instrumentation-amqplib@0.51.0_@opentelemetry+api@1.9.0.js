"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0";
exports.ids = ["vendor-chunks/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0"];
exports.modules = {

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core_1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+core@2.1.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation@0.204.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\");\n/** @knipignore */\nconst version_1 = __webpack_require__(/*! ./version */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\");\nconst supportedVersions = ['>=0.5.5 <1'];\nclass AmqplibInstrumentation extends instrumentation_1.InstrumentationBase {\n    constructor(config = {}) {\n        super(version_1.PACKAGE_NAME, version_1.PACKAGE_VERSION, { ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    setConfig(config = {}) {\n        super.setConfig({ ...types_1.DEFAULT_CONFIG, ...config });\n    }\n    init() {\n        const channelModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/channel_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const callbackModelModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/callback_model.js', supportedVersions, this.patchChannelModel.bind(this), this.unpatchChannelModel.bind(this));\n        const connectModuleFile = new instrumentation_1.InstrumentationNodeModuleFile('amqplib/lib/connect.js', supportedVersions, this.patchConnect.bind(this), this.unpatchConnect.bind(this));\n        const module = new instrumentation_1.InstrumentationNodeModuleDefinition('amqplib', supportedVersions, undefined, undefined, [channelModelModuleFile, connectModuleFile, callbackModelModuleFile]);\n        return module;\n    }\n    patchConnect(moduleExports) {\n        moduleExports = this.unpatchConnect(moduleExports);\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._wrap(moduleExports, 'connect', this.getConnectPatch.bind(this));\n        }\n        return moduleExports;\n    }\n    unpatchConnect(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.connect)) {\n            this._unwrap(moduleExports, 'connect');\n        }\n        return moduleExports;\n    }\n    patchChannelModel(moduleExports, moduleVersion) {\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._wrap(moduleExports.Channel.prototype, 'publish', this.getPublishPatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._wrap(moduleExports.Channel.prototype, 'consume', this.getConsumePatch.bind(this, moduleVersion));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._wrap(moduleExports.Channel.prototype, 'ack', this.getAckPatch.bind(this, false, types_1.EndOperation.Ack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._wrap(moduleExports.Channel.prototype, 'nack', this.getAckPatch.bind(this, true, types_1.EndOperation.Nack));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._wrap(moduleExports.Channel.prototype, 'reject', this.getAckPatch.bind(this, true, types_1.EndOperation.Reject));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'ackAll', this.getAckAllPatch.bind(this, false, types_1.EndOperation.AckAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._wrap(moduleExports.Channel.prototype, 'nackAll', this.getAckAllPatch.bind(this, true, types_1.EndOperation.NackAll));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._wrap(moduleExports.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this));\n        }\n        if (!(0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._wrap(moduleExports.ConfirmChannel.prototype, 'publish', this.getConfirmedPublishPatch.bind(this, moduleVersion));\n        }\n        return moduleExports;\n    }\n    unpatchChannelModel(moduleExports) {\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.publish)) {\n            this._unwrap(moduleExports.Channel.prototype, 'publish');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.consume)) {\n            this._unwrap(moduleExports.Channel.prototype, 'consume');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nack)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nack');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.reject)) {\n            this._unwrap(moduleExports.Channel.prototype, 'reject');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.ackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'ackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.nackAll)) {\n            this._unwrap(moduleExports.Channel.prototype, 'nackAll');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.Channel.prototype.emit)) {\n            this._unwrap(moduleExports.Channel.prototype, 'emit');\n        }\n        if ((0, instrumentation_1.isWrapped)(moduleExports.ConfirmChannel.prototype.publish)) {\n            this._unwrap(moduleExports.ConfirmChannel.prototype, 'publish');\n        }\n        return moduleExports;\n    }\n    getConnectPatch(original) {\n        return function patchedConnect(url, socketOptions, openCallback) {\n            return original.call(this, url, socketOptions, function (err, conn) {\n                if (err == null) {\n                    const urlAttributes = (0, utils_1.getConnectionAttributesFromUrl)(url);\n                    const serverAttributes = (0, utils_1.getConnectionAttributesFromServer)(conn);\n                    conn[utils_1.CONNECTION_ATTRIBUTES] = {\n                        ...urlAttributes,\n                        ...serverAttributes,\n                    };\n                }\n                openCallback.apply(this, arguments);\n            });\n        };\n    }\n    getChannelEmitPatch(original) {\n        const self = this;\n        return function emit(eventName) {\n            if (eventName === 'close') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelClosed, undefined);\n                const activeTimer = this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER];\n                if (activeTimer) {\n                    clearInterval(activeTimer);\n                }\n                this[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = undefined;\n            }\n            else if (eventName === 'error') {\n                self.endAllSpansOnChannel(this, true, types_1.EndOperation.ChannelError, undefined);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getAckAllPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ackAll(requeueOrEmpty) {\n            self.endAllSpansOnChannel(this, isRejected, endOperation, requeueOrEmpty);\n            return original.apply(this, arguments);\n        };\n    }\n    getAckPatch(isRejected, endOperation, original) {\n        const self = this;\n        return function ack(message, allUpToOrRequeue, requeue) {\n            const channel = this;\n            // we use this patch in reject function as well, but it has different signature\n            const requeueResolved = endOperation === types_1.EndOperation.Reject ? allUpToOrRequeue : requeue;\n            const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n            const msgIndex = spansNotEnded.findIndex(msgDetails => msgDetails.msg === message);\n            if (msgIndex < 0) {\n                // should not happen in happy flow\n                // but possible if user is calling the api function ack twice with same message\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n            }\n            else if (endOperation !== types_1.EndOperation.Reject && allUpToOrRequeue) {\n                for (let i = 0; i <= msgIndex; i++) {\n                    self.endConsumerSpan(spansNotEnded[i].msg, isRejected, endOperation, requeueResolved);\n                }\n                spansNotEnded.splice(0, msgIndex + 1);\n            }\n            else {\n                self.endConsumerSpan(message, isRejected, endOperation, requeueResolved);\n                spansNotEnded.splice(msgIndex, 1);\n            }\n            return original.apply(this, arguments);\n        };\n    }\n    getConsumePatch(moduleVersion, original) {\n        const self = this;\n        return function consume(queue, onMessage, options) {\n            const channel = this;\n            if (!Object.prototype.hasOwnProperty.call(channel, utils_1.CHANNEL_SPANS_NOT_ENDED)) {\n                const { consumeTimeoutMs } = self.getConfig();\n                if (consumeTimeoutMs) {\n                    const timer = setInterval(() => {\n                        self.checkConsumeTimeoutOnChannel(channel);\n                    }, consumeTimeoutMs);\n                    timer.unref();\n                    channel[utils_1.CHANNEL_CONSUME_TIMEOUT_TIMER] = timer;\n                }\n                channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n            }\n            const patchedOnMessage = function (msg) {\n                // msg is expected to be null for signaling consumer cancel notification\n                // https://www.rabbitmq.com/consumer-cancel.html\n                // in this case, we do not start a span, as this is not a real message.\n                if (!msg) {\n                    return onMessage.call(this, msg);\n                }\n                const headers = msg.properties.headers ?? {};\n                let parentContext = api_1.propagation.extract(api_1.ROOT_CONTEXT, headers);\n                const exchange = msg.fields?.exchange;\n                let links;\n                if (self._config.useLinksForConsume) {\n                    const parentSpanContext = parentContext\n                        ? api_1.trace.getSpan(parentContext)?.spanContext()\n                        : undefined;\n                    parentContext = undefined;\n                    if (parentSpanContext) {\n                        links = [\n                            {\n                                context: parentSpanContext,\n                            },\n                        ];\n                    }\n                }\n                const span = self.tracer.startSpan(`${queue} process`, {\n                    kind: api_1.SpanKind.CONSUMER,\n                    attributes: {\n                        ...channel?.connection?.[utils_1.CONNECTION_ATTRIBUTES],\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange,\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC,\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: msg.fields?.routingKey,\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_OPERATION]: semantic_conventions_1.MESSAGINGOPERATIONVALUES_PROCESS,\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: msg?.properties.messageId,\n                        [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: msg?.properties.correlationId,\n                    },\n                    links,\n                }, parentContext);\n                const { consumeHook } = self.getConfig();\n                if (consumeHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeHook(span, { moduleVersion, msg }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: consumerHook error', e);\n                        }\n                    }, true);\n                }\n                if (!options?.noAck) {\n                    // store the message on the channel so we can close the span on ackAll etc\n                    channel[utils_1.CHANNEL_SPANS_NOT_ENDED].push({\n                        msg,\n                        timeOfConsume: (0, core_1.hrTime)(),\n                    });\n                    // store the span on the message, so we can end it when user call 'ack' on it\n                    msg[utils_1.MESSAGE_STORED_SPAN] = span;\n                }\n                const setContext = parentContext\n                    ? parentContext\n                    : api_1.ROOT_CONTEXT;\n                api_1.context.with(api_1.trace.setSpan(setContext, span), () => {\n                    onMessage.call(this, msg);\n                });\n                if (options?.noAck) {\n                    self.callConsumeEndHook(span, msg, false, types_1.EndOperation.AutoAck);\n                    span.end();\n                }\n            };\n            arguments[1] = patchedOnMessage;\n            return original.apply(this, arguments);\n        };\n    }\n    getConfirmedPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function confirmedPublish(exchange, routingKey, content, options, callback) {\n            const channel = this;\n            const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n            const { publishHook } = self.getConfig();\n            if (publishHook) {\n                (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                    moduleVersion,\n                    exchange,\n                    routingKey,\n                    content,\n                    options: modifiedOptions,\n                    isConfirmChannel: true,\n                }), e => {\n                    if (e) {\n                        api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                    }\n                }, true);\n            }\n            const patchedOnConfirm = function (err, ok) {\n                try {\n                    callback?.call(this, err, ok);\n                }\n                finally {\n                    const { publishConfirmHook } = self.getConfig();\n                    if (publishConfirmHook) {\n                        (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishConfirmHook(span, {\n                            moduleVersion,\n                            exchange,\n                            routingKey,\n                            content,\n                            options,\n                            isConfirmChannel: true,\n                            confirmError: err,\n                        }), e => {\n                            if (e) {\n                                api_1.diag.error('amqplib instrumentation: publishConfirmHook error', e);\n                            }\n                        }, true);\n                    }\n                    if (err) {\n                        span.setStatus({\n                            code: api_1.SpanStatusCode.ERROR,\n                            message: \"message confirmation has been nack'ed\",\n                        });\n                    }\n                    span.end();\n                }\n            };\n            // calling confirm channel publish function is storing the message in queue and registering the callback for broker confirm.\n            // span ends in the patched callback.\n            const markedContext = (0, utils_1.markConfirmChannelTracing)(api_1.context.active());\n            const argumentsCopy = [...arguments];\n            argumentsCopy[3] = modifiedOptions;\n            argumentsCopy[4] = api_1.context.bind((0, utils_1.unmarkConfirmChannelTracing)(api_1.trace.setSpan(markedContext, span)), patchedOnConfirm);\n            return api_1.context.with(markedContext, original.bind(this, ...argumentsCopy));\n        };\n    }\n    getPublishPatch(moduleVersion, original) {\n        const self = this;\n        return function publish(exchange, routingKey, content, options) {\n            if ((0, utils_1.isConfirmChannelTracing)(api_1.context.active())) {\n                // work already done\n                return original.apply(this, arguments);\n            }\n            else {\n                const channel = this;\n                const { span, modifiedOptions } = self.createPublishSpan(self, exchange, routingKey, channel, options);\n                const { publishHook } = self.getConfig();\n                if (publishHook) {\n                    (0, instrumentation_1.safeExecuteInTheMiddle)(() => publishHook(span, {\n                        moduleVersion,\n                        exchange,\n                        routingKey,\n                        content,\n                        options: modifiedOptions,\n                        isConfirmChannel: false,\n                    }), e => {\n                        if (e) {\n                            api_1.diag.error('amqplib instrumentation: publishHook error', e);\n                        }\n                    }, true);\n                }\n                // calling normal channel publish function is only storing the message in queue.\n                // it does not send it and waits for an ack, so the span duration is expected to be very short.\n                const argumentsCopy = [...arguments];\n                argumentsCopy[3] = modifiedOptions;\n                const originalRes = original.apply(this, argumentsCopy);\n                span.end();\n                return originalRes;\n            }\n        };\n    }\n    createPublishSpan(self, exchange, routingKey, channel, options) {\n        const normalizedExchange = (0, utils_1.normalizeExchange)(exchange);\n        const span = self.tracer.startSpan(`publish ${normalizedExchange}`, {\n            kind: api_1.SpanKind.PRODUCER,\n            attributes: {\n                ...channel.connection[utils_1.CONNECTION_ATTRIBUTES],\n                [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION]: exchange,\n                [semantic_conventions_1.SEMATTRS_MESSAGING_DESTINATION_KIND]: semantic_conventions_1.MESSAGINGDESTINATIONKINDVALUES_TOPIC,\n                [semantic_conventions_1.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: routingKey,\n                [semantic_conventions_1.SEMATTRS_MESSAGING_MESSAGE_ID]: options?.messageId,\n                [semantic_conventions_1.SEMATTRS_MESSAGING_CONVERSATION_ID]: options?.correlationId,\n            },\n        });\n        const modifiedOptions = options ?? {};\n        modifiedOptions.headers = modifiedOptions.headers ?? {};\n        api_1.propagation.inject(api_1.trace.setSpan(api_1.context.active(), span), modifiedOptions.headers);\n        return { span, modifiedOptions };\n    }\n    endConsumerSpan(message, isRejected, operation, requeue) {\n        const storedSpan = message[utils_1.MESSAGE_STORED_SPAN];\n        if (!storedSpan)\n            return;\n        if (isRejected !== false) {\n            storedSpan.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: operation !== types_1.EndOperation.ChannelClosed &&\n                    operation !== types_1.EndOperation.ChannelError\n                    ? `${operation} called on message${requeue === true\n                        ? ' with requeue'\n                        : requeue === false\n                            ? ' without requeue'\n                            : ''}`\n                    : operation,\n            });\n        }\n        this.callConsumeEndHook(storedSpan, message, isRejected, operation);\n        storedSpan.end();\n        message[utils_1.MESSAGE_STORED_SPAN] = undefined;\n    }\n    endAllSpansOnChannel(channel, isRejected, operation, requeue) {\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        spansNotEnded.forEach(msgDetails => {\n            this.endConsumerSpan(msgDetails.msg, isRejected, operation, requeue);\n        });\n        channel[utils_1.CHANNEL_SPANS_NOT_ENDED] = [];\n    }\n    callConsumeEndHook(span, msg, rejected, endOperation) {\n        const { consumeEndHook } = this.getConfig();\n        if (!consumeEndHook)\n            return;\n        (0, instrumentation_1.safeExecuteInTheMiddle)(() => consumeEndHook(span, { msg, rejected, endOperation }), e => {\n            if (e) {\n                api_1.diag.error('amqplib instrumentation: consumerEndHook error', e);\n            }\n        }, true);\n    }\n    checkConsumeTimeoutOnChannel(channel) {\n        const currentTime = (0, core_1.hrTime)();\n        const spansNotEnded = channel[utils_1.CHANNEL_SPANS_NOT_ENDED] ?? [];\n        let i;\n        const { consumeTimeoutMs } = this.getConfig();\n        for (i = 0; i < spansNotEnded.length; i++) {\n            const currMessage = spansNotEnded[i];\n            const timeFromConsume = (0, core_1.hrTimeDuration)(currMessage.timeOfConsume, currentTime);\n            if ((0, core_1.hrTimeToMilliseconds)(timeFromConsume) < consumeTimeoutMs) {\n                break;\n            }\n            this.endConsumerSpan(currMessage.msg, null, types_1.EndOperation.InstrumentationTimeout, true);\n        }\n        spansNotEnded.splice(0, i);\n    }\n}\nexports.AmqplibInstrumentation = AmqplibInstrumentation;\n//# sourceMappingURL=amqplib.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvYW1xcGxpYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLDZJQUFvQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMseUtBQXFCO0FBQzVDLDBCQUEwQixtQkFBTyxDQUFDLDRNQUFnQztBQUNsRSwrQkFBK0IsbUJBQU8sQ0FBQyxpTUFBcUM7QUFDNUUsZ0JBQWdCLG1CQUFPLENBQUMsb01BQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsb01BQVM7QUFDakM7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx3TUFBVztBQUNyQztBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLG1FQUFtRSxzQ0FBc0M7QUFDekc7QUFDQSx5QkFBeUI7QUFDekIsMEJBQTBCLHNDQUFzQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQix3QkFBd0IsY0FBYztBQUN0QztBQUNBLDRGQUE0RixvQkFBb0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QyxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG1GQUFtRiw2QkFBNkI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTEuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy9hbXFwbGliLmpzP2IzZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFtcXBsaWJJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2NvcmVcIik7XG5jb25zdCBpbnN0cnVtZW50YXRpb25fMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb25cIik7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqIEBrbmlwaWdub3JlICovXG5jb25zdCB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuY29uc3Qgc3VwcG9ydGVkVmVyc2lvbnMgPSBbJz49MC41LjUgPDEnXTtcbmNsYXNzIEFtcXBsaWJJbnN0cnVtZW50YXRpb24gZXh0ZW5kcyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25CYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih2ZXJzaW9uXzEuUEFDS0FHRV9OQU1FLCB2ZXJzaW9uXzEuUEFDS0FHRV9WRVJTSU9OLCB7IC4uLnR5cGVzXzEuREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9KTtcbiAgICB9XG4gICAgc2V0Q29uZmlnKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHN1cGVyLnNldENvbmZpZyh7IC4uLnR5cGVzXzEuREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9KTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbE1vZGVsTW9kdWxlRmlsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRmlsZSgnYW1xcGxpYi9saWIvY2hhbm5lbF9tb2RlbC5qcycsIHN1cHBvcnRlZFZlcnNpb25zLCB0aGlzLnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcyksIHRoaXMudW5wYXRjaENoYW5uZWxNb2RlbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tNb2RlbE1vZHVsZUZpbGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZUZpbGUoJ2FtcXBsaWIvbGliL2NhbGxiYWNrX21vZGVsLmpzJywgc3VwcG9ydGVkVmVyc2lvbnMsIHRoaXMucGF0Y2hDaGFubmVsTW9kZWwuYmluZCh0aGlzKSwgdGhpcy51bnBhdGNoQ2hhbm5lbE1vZGVsLmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBjb25uZWN0TW9kdWxlRmlsZSA9IG5ldyBpbnN0cnVtZW50YXRpb25fMS5JbnN0cnVtZW50YXRpb25Ob2RlTW9kdWxlRmlsZSgnYW1xcGxpYi9saWIvY29ubmVjdC5qcycsIHN1cHBvcnRlZFZlcnNpb25zLCB0aGlzLnBhdGNoQ29ubmVjdC5iaW5kKHRoaXMpLCB0aGlzLnVucGF0Y2hDb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBuZXcgaW5zdHJ1bWVudGF0aW9uXzEuSW5zdHJ1bWVudGF0aW9uTm9kZU1vZHVsZURlZmluaXRpb24oJ2FtcXBsaWInLCBzdXBwb3J0ZWRWZXJzaW9ucywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFtjaGFubmVsTW9kZWxNb2R1bGVGaWxlLCBjb25uZWN0TW9kdWxlRmlsZSwgY2FsbGJhY2tNb2RlbE1vZHVsZUZpbGVdKTtcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gICAgcGF0Y2hDb25uZWN0KG1vZHVsZUV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlRXhwb3J0cyA9IHRoaXMudW5wYXRjaENvbm5lY3QobW9kdWxlRXhwb3J0cyk7XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5jb25uZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLCAnY29ubmVjdCcsIHRoaXMuZ2V0Q29ubmVjdFBhdGNoLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVFeHBvcnRzO1xuICAgIH1cbiAgICB1bnBhdGNoQ29ubmVjdChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLmNvbm5lY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cywgJ2Nvbm5lY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgcGF0Y2hDaGFubmVsTW9kZWwobW9kdWxlRXhwb3J0cywgbW9kdWxlVmVyc2lvbikge1xuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnLCB0aGlzLmdldFB1Ymxpc2hQYXRjaC5iaW5kKHRoaXMsIG1vZHVsZVZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuY29uc3VtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2NvbnN1bWUnLCB0aGlzLmdldENvbnN1bWVQYXRjaC5iaW5kKHRoaXMsIG1vZHVsZVZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLCAnYWNrJywgdGhpcy5nZXRBY2tQYXRjaC5iaW5kKHRoaXMsIGZhbHNlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5BY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUubmFjaykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2snLCB0aGlzLmdldEFja1BhdGNoLmJpbmQodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uTmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5yZWplY3QpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdyZWplY3QnLCB0aGlzLmdldEFja1BhdGNoLmJpbmQodGhpcywgdHJ1ZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uUmVqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLmFja0FsbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2Fja0FsbCcsIHRoaXMuZ2V0QWNrQWxsUGF0Y2guYmluZCh0aGlzLCBmYWxzZSwgdHlwZXNfMS5FbmRPcGVyYXRpb24uQWNrQWxsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2tBbGwpKSB7XG4gICAgICAgICAgICB0aGlzLl93cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrQWxsJywgdGhpcy5nZXRBY2tBbGxQYXRjaC5iaW5kKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLk5hY2tBbGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuZW1pdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2VtaXQnLCB0aGlzLmdldENoYW5uZWxFbWl0UGF0Y2guYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoKSkge1xuICAgICAgICAgICAgdGhpcy5fd3JhcChtb2R1bGVFeHBvcnRzLkNvbmZpcm1DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnLCB0aGlzLmdldENvbmZpcm1lZFB1Ymxpc2hQYXRjaC5iaW5kKHRoaXMsIG1vZHVsZVZlcnNpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kdWxlRXhwb3J0cztcbiAgICB9XG4gICAgdW5wYXRjaENoYW5uZWxNb2RlbChtb2R1bGVFeHBvcnRzKSB7XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ3B1Ymxpc2gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5jb25zdW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdjb25zdW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUuYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5uYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICduYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUucmVqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdyZWplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5hY2tBbGwpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ2Fja0FsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgaW5zdHJ1bWVudGF0aW9uXzEuaXNXcmFwcGVkKShtb2R1bGVFeHBvcnRzLkNoYW5uZWwucHJvdG90eXBlLm5hY2tBbGwpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZSwgJ25hY2tBbGwnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGluc3RydW1lbnRhdGlvbl8xLmlzV3JhcHBlZCkobW9kdWxlRXhwb3J0cy5DaGFubmVsLnByb3RvdHlwZS5lbWl0KSkge1xuICAgICAgICAgICAgdGhpcy5fdW53cmFwKG1vZHVsZUV4cG9ydHMuQ2hhbm5lbC5wcm90b3R5cGUsICdlbWl0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBpbnN0cnVtZW50YXRpb25fMS5pc1dyYXBwZWQpKG1vZHVsZUV4cG9ydHMuQ29uZmlybUNoYW5uZWwucHJvdG90eXBlLnB1Ymxpc2gpKSB7XG4gICAgICAgICAgICB0aGlzLl91bndyYXAobW9kdWxlRXhwb3J0cy5Db25maXJtQ2hhbm5lbC5wcm90b3R5cGUsICdwdWJsaXNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZUV4cG9ydHM7XG4gICAgfVxuICAgIGdldENvbm5lY3RQYXRjaChvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcGF0Y2hlZENvbm5lY3QodXJsLCBzb2NrZXRPcHRpb25zLCBvcGVuQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5jYWxsKHRoaXMsIHVybCwgc29ja2V0T3B0aW9ucywgZnVuY3Rpb24gKGVyciwgY29ubikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tVXJsKSh1cmwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJBdHRyaWJ1dGVzID0gKDAsIHV0aWxzXzEuZ2V0Q29ubmVjdGlvbkF0dHJpYnV0ZXNGcm9tU2VydmVyKShjb25uKTtcbiAgICAgICAgICAgICAgICAgICAgY29ublt1dGlsc18xLkNPTk5FQ1RJT05fQVRUUklCVVRFU10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51cmxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc2VydmVyQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3BlbkNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbEVtaXRQYXRjaChvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGVtaXQoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbmRBbGxTcGFuc09uQ2hhbm5lbCh0aGlzLCB0cnVlLCB0eXBlc18xLkVuZE9wZXJhdGlvbi5DaGFubmVsQ2xvc2VkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRpbWVyID0gdGhpc1t1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChhY3RpdmVUaW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNbdXRpbHNfMS5DSEFOTkVMX0NPTlNVTUVfVElNRU9VVF9USU1FUl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIHRydWUsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxFcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRBY2tBbGxQYXRjaChpc1JlamVjdGVkLCBlbmRPcGVyYXRpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYWNrQWxsKHJlcXVldWVPckVtcHR5KSB7XG4gICAgICAgICAgICBzZWxmLmVuZEFsbFNwYW5zT25DaGFubmVsKHRoaXMsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZU9yRW1wdHkpO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEFja1BhdGNoKGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgb3JpZ2luYWwpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhY2sobWVzc2FnZSwgYWxsVXBUb09yUmVxdWV1ZSwgcmVxdWV1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXM7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgdGhpcyBwYXRjaCBpbiByZWplY3QgZnVuY3Rpb24gYXMgd2VsbCwgYnV0IGl0IGhhcyBkaWZmZXJlbnQgc2lnbmF0dXJlXG4gICAgICAgICAgICBjb25zdCByZXF1ZXVlUmVzb2x2ZWQgPSBlbmRPcGVyYXRpb24gPT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLlJlamVjdCA/IGFsbFVwVG9PclJlcXVldWUgOiByZXF1ZXVlO1xuICAgICAgICAgICAgY29uc3Qgc3BhbnNOb3RFbmRlZCA9IGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0gPz8gW107XG4gICAgICAgICAgICBjb25zdCBtc2dJbmRleCA9IHNwYW5zTm90RW5kZWQuZmluZEluZGV4KG1zZ0RldGFpbHMgPT4gbXNnRGV0YWlscy5tc2cgPT09IG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG1zZ0luZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgaGFwcGVuIGluIGhhcHB5IGZsb3dcbiAgICAgICAgICAgICAgICAvLyBidXQgcG9zc2libGUgaWYgdXNlciBpcyBjYWxsaW5nIHRoZSBhcGkgZnVuY3Rpb24gYWNrIHR3aWNlIHdpdGggc2FtZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4obWVzc2FnZSwgaXNSZWplY3RlZCwgZW5kT3BlcmF0aW9uLCByZXF1ZXVlUmVzb2x2ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kT3BlcmF0aW9uICE9PSB0eXBlc18xLkVuZE9wZXJhdGlvbi5SZWplY3QgJiYgYWxsVXBUb09yUmVxdWV1ZSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1zZ0luZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmRDb25zdW1lclNwYW4oc3BhbnNOb3RFbmRlZFtpXS5tc2csIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BhbnNOb3RFbmRlZC5zcGxpY2UoMCwgbXNnSW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZW5kQ29uc3VtZXJTcGFuKG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIGVuZE9wZXJhdGlvbiwgcmVxdWV1ZVJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICBzcGFuc05vdEVuZGVkLnNwbGljZShtc2dJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZVBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3VtZShxdWV1ZSwgb25NZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoYW5uZWwsIHV0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERUQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25zdW1lVGltZW91dE1zIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lVGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGVja0NvbnN1bWVUaW1lb3V0T25DaGFubmVsKGNoYW5uZWwpO1xuICAgICAgICAgICAgICAgICAgICB9LCBjb25zdW1lVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfQ09OU1VNRV9USU1FT1VUX1RJTUVSXSA9IHRpbWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaGVkT25NZXNzYWdlID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgICAgIC8vIG1zZyBpcyBleHBlY3RlZCB0byBiZSBudWxsIGZvciBzaWduYWxpbmcgY29uc3VtZXIgY2FuY2VsIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJhYmJpdG1xLmNvbS9jb25zdW1lci1jYW5jZWwuaHRtbFxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSwgd2UgZG8gbm90IHN0YXJ0IGEgc3BhbiwgYXMgdGhpcyBpcyBub3QgYSByZWFsIG1lc3NhZ2UuXG4gICAgICAgICAgICAgICAgaWYgKCFtc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9uTWVzc2FnZS5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBtc2cucHJvcGVydGllcy5oZWFkZXJzID8/IHt9O1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRDb250ZXh0ID0gYXBpXzEucHJvcGFnYXRpb24uZXh0cmFjdChhcGlfMS5ST09UX0NPTlRFWFQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2hhbmdlID0gbXNnLmZpZWxkcz8uZXhjaGFuZ2U7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmtzO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9jb25maWcudXNlTGlua3NGb3JDb25zdW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFNwYW5Db250ZXh0ID0gcGFyZW50Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhcGlfMS50cmFjZS5nZXRTcGFuKHBhcmVudENvbnRleHQpPy5zcGFuQ29udGV4dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFNwYW5Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHBhcmVudFNwYW5Db250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBzZWxmLnRyYWNlci5zdGFydFNwYW4oYCR7cXVldWV9IHByb2Nlc3NgLCB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQ6IGFwaV8xLlNwYW5LaW5kLkNPTlNVTUVSLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jaGFubmVsPy5jb25uZWN0aW9uPy5bdXRpbHNfMS5DT05ORUNUSU9OX0FUVFJJQlVURVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX0RFU1RJTkFUSU9OXTogZXhjaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfREVTVElOQVRJT05fS0lORF06IHNlbWFudGljX2NvbnZlbnRpb25zXzEuTUVTU0FHSU5HREVTVElOQVRJT05LSU5EVkFMVUVTX1RPUElDLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogbXNnLmZpZWxkcz8ucm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19PUEVSQVRJT05dOiBzZW1hbnRpY19jb252ZW50aW9uc18xLk1FU1NBR0lOR09QRVJBVElPTlZBTFVFU19QUk9DRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX01FU1NBR0VfSURdOiBtc2c/LnByb3BlcnRpZXMubWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX0NPTlZFUlNBVElPTl9JRF06IG1zZz8ucHJvcGVydGllcy5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsaW5rcyxcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnRDb250ZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnN1bWVIb29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIGlmIChjb25zdW1lSG9vaykge1xuICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gY29uc3VtZUhvb2soc3BhbiwgeyBtb2R1bGVWZXJzaW9uLCBtc2cgfSksIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogY29uc3VtZXJIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnM/Lm5vQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBtZXNzYWdlIG9uIHRoZSBjaGFubmVsIHNvIHdlIGNhbiBjbG9zZSB0aGUgc3BhbiBvbiBhY2tBbGwgZXRjXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxbdXRpbHNfMS5DSEFOTkVMX1NQQU5TX05PVF9FTkRFRF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lT2ZDb25zdW1lOiAoMCwgY29yZV8xLmhyVGltZSkoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzcGFuIG9uIHRoZSBtZXNzYWdlLCBzbyB3ZSBjYW4gZW5kIGl0IHdoZW4gdXNlciBjYWxsICdhY2snIG9uIGl0XG4gICAgICAgICAgICAgICAgICAgIG1zZ1t1dGlsc18xLk1FU1NBR0VfU1RPUkVEX1NQQU5dID0gc3BhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0Q29udGV4dCA9IHBhcmVudENvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnRDb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIDogYXBpXzEuUk9PVF9DT05URVhUO1xuICAgICAgICAgICAgICAgIGFwaV8xLmNvbnRleHQud2l0aChhcGlfMS50cmFjZS5zZXRTcGFuKHNldENvbnRleHQsIHNwYW4pLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uTWVzc2FnZS5jYWxsKHRoaXMsIG1zZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnM/Lm5vQWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FsbENvbnN1bWVFbmRIb29rKHNwYW4sIG1zZywgZmFsc2UsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkF1dG9BY2spO1xuICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhcmd1bWVudHNbMV0gPSBwYXRjaGVkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENvbmZpcm1lZFB1Ymxpc2hQYXRjaChtb2R1bGVWZXJzaW9uLCBvcmlnaW5hbCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbmZpcm1lZFB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgc3BhbiwgbW9kaWZpZWRPcHRpb25zIH0gPSBzZWxmLmNyZWF0ZVB1Ymxpc2hTcGFuKHNlbGYsIGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjaGFubmVsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaEhvb2sgfSA9IHNlbGYuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBpZiAocHVibGlzaEhvb2spIHtcbiAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaEhvb2soc3Bhbiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogbW9kaWZpZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpc0NvbmZpcm1DaGFubmVsOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoJ2FtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBwdWJsaXNoSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRjaGVkT25Db25maXJtID0gZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaz8uY2FsbCh0aGlzLCBlcnIsIG9rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHVibGlzaENvbmZpcm1Ib29rIH0gPSBzZWxmLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVibGlzaENvbmZpcm1Ib29rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEuc2FmZUV4ZWN1dGVJblRoZU1pZGRsZSkoKCkgPT4gcHVibGlzaENvbmZpcm1Ib29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVWZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uZmlybUNoYW5uZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hDb25maXJtSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2UgY29uZmlybWF0aW9uIGhhcyBiZWVuIG5hY2snZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgY29uZmlybSBjaGFubmVsIHB1Ymxpc2ggZnVuY3Rpb24gaXMgc3RvcmluZyB0aGUgbWVzc2FnZSBpbiBxdWV1ZSBhbmQgcmVnaXN0ZXJpbmcgdGhlIGNhbGxiYWNrIGZvciBicm9rZXIgY29uZmlybS5cbiAgICAgICAgICAgIC8vIHNwYW4gZW5kcyBpbiB0aGUgcGF0Y2hlZCBjYWxsYmFjay5cbiAgICAgICAgICAgIGNvbnN0IG1hcmtlZENvbnRleHQgPSAoMCwgdXRpbHNfMS5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c0NvcHkgPSBbLi4uYXJndW1lbnRzXTtcbiAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbM10gPSBtb2RpZmllZE9wdGlvbnM7XG4gICAgICAgICAgICBhcmd1bWVudHNDb3B5WzRdID0gYXBpXzEuY29udGV4dC5iaW5kKCgwLCB1dGlsc18xLnVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZykoYXBpXzEudHJhY2Uuc2V0U3BhbihtYXJrZWRDb250ZXh0LCBzcGFuKSksIHBhdGNoZWRPbkNvbmZpcm0pO1xuICAgICAgICAgICAgcmV0dXJuIGFwaV8xLmNvbnRleHQud2l0aChtYXJrZWRDb250ZXh0LCBvcmlnaW5hbC5iaW5kKHRoaXMsIC4uLmFyZ3VtZW50c0NvcHkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0UHVibGlzaFBhdGNoKG1vZHVsZVZlcnNpb24sIG9yaWdpbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gcHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCgwLCB1dGlsc18xLmlzQ29uZmlybUNoYW5uZWxUcmFjaW5nKShhcGlfMS5jb250ZXh0LmFjdGl2ZSgpKSkge1xuICAgICAgICAgICAgICAgIC8vIHdvcmsgYWxyZWFkeSBkb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwYW4sIG1vZGlmaWVkT3B0aW9ucyB9ID0gc2VsZi5jcmVhdGVQdWJsaXNoU3BhbihzZWxmLCBleGNoYW5nZSwgcm91dGluZ0tleSwgY2hhbm5lbCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwdWJsaXNoSG9vayB9ID0gc2VsZi5nZXRDb25maWcoKTtcbiAgICAgICAgICAgICAgICBpZiAocHVibGlzaEhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IHB1Ymxpc2hIb29rKHNwYW4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZVZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRpbmdLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogbW9kaWZpZWRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25maXJtQ2hhbm5lbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IHB1Ymxpc2hIb29rIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjYWxsaW5nIG5vcm1hbCBjaGFubmVsIHB1Ymxpc2ggZnVuY3Rpb24gaXMgb25seSBzdG9yaW5nIHRoZSBtZXNzYWdlIGluIHF1ZXVlLlxuICAgICAgICAgICAgICAgIC8vIGl0IGRvZXMgbm90IHNlbmQgaXQgYW5kIHdhaXRzIGZvciBhbiBhY2ssIHNvIHRoZSBzcGFuIGR1cmF0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIHZlcnkgc2hvcnQuXG4gICAgICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzQ29weSA9IFsuLi5hcmd1bWVudHNdO1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50c0NvcHlbM10gPSBtb2RpZmllZE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXMgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHNDb3B5KTtcbiAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlUHVibGlzaFNwYW4oc2VsZiwgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEV4Y2hhbmdlID0gKDAsIHV0aWxzXzEubm9ybWFsaXplRXhjaGFuZ2UpKGV4Y2hhbmdlKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNlbGYudHJhY2VyLnN0YXJ0U3BhbihgcHVibGlzaCAke25vcm1hbGl6ZWRFeGNoYW5nZX1gLCB7XG4gICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5QUk9EVUNFUixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5jaGFubmVsLmNvbm5lY3Rpb25bdXRpbHNfMS5DT05ORUNUSU9OX0FUVFJJQlVURVNdLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl06IGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19ERVNUSU5BVElPTl9LSU5EXTogc2VtYW50aWNfY29udmVudGlvbnNfMS5NRVNTQUdJTkdERVNUSU5BVElPTktJTkRWQUxVRVNfVE9QSUMsXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTUVTU0FHSU5HX1JBQkJJVE1RX1JPVVRJTkdfS0VZXTogcm91dGluZ0tleSxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfTUVTU0FHRV9JRF06IG9wdGlvbnM/Lm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfQ09OVkVSU0FUSU9OX0lEXTogb3B0aW9ucz8uY29ycmVsYXRpb25JZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtb2RpZmllZE9wdGlvbnMgPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBtb2RpZmllZE9wdGlvbnMuaGVhZGVycyA9IG1vZGlmaWVkT3B0aW9ucy5oZWFkZXJzID8/IHt9O1xuICAgICAgICBhcGlfMS5wcm9wYWdhdGlvbi5pbmplY3QoYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSwgbW9kaWZpZWRPcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICByZXR1cm4geyBzcGFuLCBtb2RpZmllZE9wdGlvbnMgfTtcbiAgICB9XG4gICAgZW5kQ29uc3VtZXJTcGFuKG1lc3NhZ2UsIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbiwgcmVxdWV1ZSkge1xuICAgICAgICBjb25zdCBzdG9yZWRTcGFuID0gbWVzc2FnZVt1dGlsc18xLk1FU1NBR0VfU1RPUkVEX1NQQU5dO1xuICAgICAgICBpZiAoIXN0b3JlZFNwYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChpc1JlamVjdGVkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RvcmVkU3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wZXJhdGlvbiAhPT0gdHlwZXNfMS5FbmRPcGVyYXRpb24uQ2hhbm5lbENsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24gIT09IHR5cGVzXzEuRW5kT3BlcmF0aW9uLkNoYW5uZWxFcnJvclxuICAgICAgICAgICAgICAgICAgICA/IGAke29wZXJhdGlvbn0gY2FsbGVkIG9uIG1lc3NhZ2Uke3JlcXVldWUgPT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJyB3aXRoIHJlcXVldWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlcXVldWUgPT09IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnIHdpdGhvdXQgcmVxdWV1ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcnfWBcbiAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxDb25zdW1lRW5kSG9vayhzdG9yZWRTcGFuLCBtZXNzYWdlLCBpc1JlamVjdGVkLCBvcGVyYXRpb24pO1xuICAgICAgICBzdG9yZWRTcGFuLmVuZCgpO1xuICAgICAgICBtZXNzYWdlW3V0aWxzXzEuTUVTU0FHRV9TVE9SRURfU1BBTl0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuZEFsbFNwYW5zT25DaGFubmVsKGNoYW5uZWwsIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbiwgcmVxdWV1ZSkge1xuICAgICAgICBjb25zdCBzcGFuc05vdEVuZGVkID0gY2hhbm5lbFt1dGlsc18xLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEXSA/PyBbXTtcbiAgICAgICAgc3BhbnNOb3RFbmRlZC5mb3JFYWNoKG1zZ0RldGFpbHMgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmRDb25zdW1lclNwYW4obXNnRGV0YWlscy5tc2csIGlzUmVqZWN0ZWQsIG9wZXJhdGlvbiwgcmVxdWV1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID0gW107XG4gICAgfVxuICAgIGNhbGxDb25zdW1lRW5kSG9vayhzcGFuLCBtc2csIHJlamVjdGVkLCBlbmRPcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3QgeyBjb25zdW1lRW5kSG9vayB9ID0gdGhpcy5nZXRDb25maWcoKTtcbiAgICAgICAgaWYgKCFjb25zdW1lRW5kSG9vaylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKDAsIGluc3RydW1lbnRhdGlvbl8xLnNhZmVFeGVjdXRlSW5UaGVNaWRkbGUpKCgpID0+IGNvbnN1bWVFbmRIb29rKHNwYW4sIHsgbXNnLCByZWplY3RlZCwgZW5kT3BlcmF0aW9uIH0pLCBlID0+IHtcbiAgICAgICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICAgICAgYXBpXzEuZGlhZy5lcnJvcignYW1xcGxpYiBpbnN0cnVtZW50YXRpb246IGNvbnN1bWVyRW5kSG9vayBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgY2hlY2tDb25zdW1lVGltZW91dE9uQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gKDAsIGNvcmVfMS5oclRpbWUpKCk7XG4gICAgICAgIGNvbnN0IHNwYW5zTm90RW5kZWQgPSBjaGFubmVsW3V0aWxzXzEuQ0hBTk5FTF9TUEFOU19OT1RfRU5ERURdID8/IFtdO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgeyBjb25zdW1lVGltZW91dE1zIH0gPSB0aGlzLmdldENvbmZpZygpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhbnNOb3RFbmRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3Vyck1lc3NhZ2UgPSBzcGFuc05vdEVuZGVkW2ldO1xuICAgICAgICAgICAgY29uc3QgdGltZUZyb21Db25zdW1lID0gKDAsIGNvcmVfMS5oclRpbWVEdXJhdGlvbikoY3Vyck1lc3NhZ2UudGltZU9mQ29uc3VtZSwgY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgaWYgKCgwLCBjb3JlXzEuaHJUaW1lVG9NaWxsaXNlY29uZHMpKHRpbWVGcm9tQ29uc3VtZSkgPCBjb25zdW1lVGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuZENvbnN1bWVyU3BhbihjdXJyTWVzc2FnZS5tc2csIG51bGwsIHR5cGVzXzEuRW5kT3BlcmF0aW9uLkluc3RydW1lbnRhdGlvblRpbWVvdXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHNwYW5zTm90RW5kZWQuc3BsaWNlKDAsIGkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW1xcGxpYkluc3RydW1lbnRhdGlvbiA9IEFtcXBsaWJJbnN0cnVtZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXFwbGliLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndOperation = exports.DEFAULT_CONFIG = exports.AmqplibInstrumentation = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar amqplib_1 = __webpack_require__(/*! ./amqplib */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/amqplib.js\");\nObject.defineProperty(exports, \"AmqplibInstrumentation\", ({ enumerable: true, get: function () { return amqplib_1.AmqplibInstrumentation; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\");\nObject.defineProperty(exports, \"DEFAULT_CONFIG\", ({ enumerable: true, get: function () { return types_1.DEFAULT_CONFIG; } }));\nObject.defineProperty(exports, \"EndOperation\", ({ enumerable: true, get: function () { return types_1.EndOperation; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsc0JBQXNCLEdBQUcsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdNQUFXO0FBQ25DLDBEQUF5RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUM3SSxjQUFjLG1CQUFPLENBQUMsb01BQVM7QUFDL0Isa0RBQWlELEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQzNILGdEQUErQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN2SCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW50ZWxlbWV0cnkraW5zdHJ1bWVudGF0aW9uLWFtcXBsaWJAMC41MS4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMC9ub2RlX21vZHVsZXMvQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uLWFtcXBsaWIvYnVpbGQvc3JjL2luZGV4LmpzPzgxMDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVuZE9wZXJhdGlvbiA9IGV4cG9ydHMuREVGQVVMVF9DT05GSUcgPSBleHBvcnRzLkFtcXBsaWJJbnN0cnVtZW50YXRpb24gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IFRoZSBPcGVuVGVsZW1ldHJ5IEF1dGhvcnNcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGFtcXBsaWJfMSA9IHJlcXVpcmUoXCIuL2FtcXBsaWJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbXFwbGliSW5zdHJ1bWVudGF0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhbXFwbGliXzEuQW1xcGxpYkluc3RydW1lbnRhdGlvbjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJERUZBVUxUX0NPTkZJR1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5ERUZBVUxUX0NPTkZJRzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVuZE9wZXJhdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5FbmRPcGVyYXRpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/index.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CONFIG = exports.EndOperation = void 0;\nvar EndOperation;\n(function (EndOperation) {\n    EndOperation[\"AutoAck\"] = \"auto ack\";\n    EndOperation[\"Ack\"] = \"ack\";\n    EndOperation[\"AckAll\"] = \"ackAll\";\n    EndOperation[\"Reject\"] = \"reject\";\n    EndOperation[\"Nack\"] = \"nack\";\n    EndOperation[\"NackAll\"] = \"nackAll\";\n    EndOperation[\"ChannelClosed\"] = \"channel closed\";\n    EndOperation[\"ChannelError\"] = \"channel error\";\n    EndOperation[\"InstrumentationTimeout\"] = \"instrumentation timeout\";\n})(EndOperation = exports.EndOperation || (exports.EndOperation = {}));\nexports.DEFAULT_CONFIG = {\n    consumeTimeoutMs: 1000 * 60,\n    useLinksForConsume: false,\n};\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQyxvQkFBb0IsS0FBSztBQUNwRSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTEuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy90eXBlcy5qcz8wNzBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IGV4cG9ydHMuRW5kT3BlcmF0aW9uID0gdm9pZCAwO1xudmFyIEVuZE9wZXJhdGlvbjtcbihmdW5jdGlvbiAoRW5kT3BlcmF0aW9uKSB7XG4gICAgRW5kT3BlcmF0aW9uW1wiQXV0b0Fja1wiXSA9IFwiYXV0byBhY2tcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJBY2tcIl0gPSBcImFja1wiO1xuICAgIEVuZE9wZXJhdGlvbltcIkFja0FsbFwiXSA9IFwiYWNrQWxsXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiUmVqZWN0XCJdID0gXCJyZWplY3RcIjtcbiAgICBFbmRPcGVyYXRpb25bXCJOYWNrXCJdID0gXCJuYWNrXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiTmFja0FsbFwiXSA9IFwibmFja0FsbFwiO1xuICAgIEVuZE9wZXJhdGlvbltcIkNoYW5uZWxDbG9zZWRcIl0gPSBcImNoYW5uZWwgY2xvc2VkXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiQ2hhbm5lbEVycm9yXCJdID0gXCJjaGFubmVsIGVycm9yXCI7XG4gICAgRW5kT3BlcmF0aW9uW1wiSW5zdHJ1bWVudGF0aW9uVGltZW91dFwiXSA9IFwiaW5zdHJ1bWVudGF0aW9uIHRpbWVvdXRcIjtcbn0pKEVuZE9wZXJhdGlvbiA9IGV4cG9ydHMuRW5kT3BlcmF0aW9uIHx8IChleHBvcnRzLkVuZE9wZXJhdGlvbiA9IHt9KSk7XG5leHBvcnRzLkRFRkFVTFRfQ09ORklHID0ge1xuICAgIGNvbnN1bWVUaW1lb3V0TXM6IDEwMDAgKiA2MCxcbiAgICB1c2VMaW5rc0ZvckNvbnN1bWU6IGZhbHNlLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/types.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js":
/*!******************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js ***!
  \******************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConfirmChannelTracing = exports.unmarkConfirmChannelTracing = exports.markConfirmChannelTracing = exports.getConnectionAttributesFromUrl = exports.getConnectionAttributesFromServer = exports.normalizeExchange = exports.CONNECTION_ATTRIBUTES = exports.CHANNEL_CONSUME_TIMEOUT_TIMER = exports.CHANNEL_SPANS_NOT_ENDED = exports.MESSAGE_STORED_SPAN = void 0;\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/../../node_modules/.pnpm/@opentelemetry+semantic-conventions@1.37.0/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nexports.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span');\nexports.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended');\nexports.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol('opentelemetry.amqplib.channel.consumer-timeout-timer');\nexports.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes');\nconst IS_CONFIRM_CHANNEL_CONTEXT_KEY = (0, api_1.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');\nconst normalizeExchange = (exchangeName) => exchangeName !== '' ? exchangeName : '<default>';\nexports.normalizeExchange = normalizeExchange;\nconst censorPassword = (url) => {\n    return url.replace(/:[^:@/]*@/, ':***@');\n};\nconst getPort = (portFromUrl, resolvedProtocol) => {\n    // we are using the resolved protocol which is upper case\n    // this code mimic the behavior of the amqplib which is used to set connection params\n    return portFromUrl || (resolvedProtocol === 'AMQP' ? 5672 : 5671);\n};\nconst getProtocol = (protocolFromUrl) => {\n    const resolvedProtocol = protocolFromUrl || 'amqp';\n    // the substring removed the ':' part of the protocol ('amqp:' -> 'amqp')\n    const noEndingColon = resolvedProtocol.endsWith(':')\n        ? resolvedProtocol.substring(0, resolvedProtocol.length - 1)\n        : resolvedProtocol;\n    // upper cases to match spec\n    return noEndingColon.toUpperCase();\n};\nconst getHostname = (hostnameFromUrl) => {\n    // if user supplies empty hostname, it gets forwarded to 'net' package which default it to localhost.\n    // https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect_options_connectlistener\n    return hostnameFromUrl || 'localhost';\n};\nconst extractConnectionAttributeOrLog = (url, attributeKey, attributeValue, nameForLog) => {\n    if (attributeValue) {\n        return { [attributeKey]: attributeValue };\n    }\n    else {\n        api_1.diag.error(`amqplib instrumentation: could not extract connection attribute ${nameForLog} from user supplied url`, {\n            url,\n        });\n        return {};\n    }\n};\nconst getConnectionAttributesFromServer = (conn) => {\n    const product = conn.serverProperties.product?.toLowerCase?.();\n    if (product) {\n        return {\n            [semantic_conventions_1.SEMATTRS_MESSAGING_SYSTEM]: product,\n        };\n    }\n    else {\n        return {};\n    }\n};\nexports.getConnectionAttributesFromServer = getConnectionAttributesFromServer;\nconst getConnectionAttributesFromUrl = (url) => {\n    const attributes = {\n        [semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: '0.9.1', // this is the only protocol supported by the instrumented library\n    };\n    url = url || 'amqp://localhost';\n    if (typeof url === 'object') {\n        const connectOptions = url;\n        const protocol = getProtocol(connectOptions?.protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol'),\n        });\n        const hostname = getHostname(connectOptions?.hostname);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname'),\n        });\n        const port = getPort(connectOptions.port, protocol);\n        Object.assign(attributes, {\n            ...extractConnectionAttributeOrLog(url, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port'),\n        });\n    }\n    else {\n        const censoredUrl = censorPassword(url);\n        attributes[semantic_conventions_1.SEMATTRS_MESSAGING_URL] = censoredUrl;\n        try {\n            const urlParts = new URL(censoredUrl);\n            const protocol = getProtocol(urlParts.protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_MESSAGING_PROTOCOL, protocol, 'protocol'),\n            });\n            const hostname = getHostname(urlParts.hostname);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_NAME, hostname, 'hostname'),\n            });\n            const port = getPort(urlParts.port ? parseInt(urlParts.port) : undefined, protocol);\n            Object.assign(attributes, {\n                ...extractConnectionAttributeOrLog(censoredUrl, semantic_conventions_1.SEMATTRS_NET_PEER_PORT, port, 'port'),\n            });\n        }\n        catch (err) {\n            api_1.diag.error('amqplib instrumentation: error while extracting connection details from connection url', {\n                censoredUrl,\n                err,\n            });\n        }\n    }\n    return attributes;\n};\nexports.getConnectionAttributesFromUrl = getConnectionAttributesFromUrl;\nconst markConfirmChannelTracing = (context) => {\n    return context.setValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY, true);\n};\nexports.markConfirmChannelTracing = markConfirmChannelTracing;\nconst unmarkConfirmChannelTracing = (context) => {\n    return context.deleteValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY);\n};\nexports.unmarkConfirmChannelTracing = unmarkConfirmChannelTracing;\nconst isConfirmChannelTracing = (context) => {\n    return context.getValue(IS_CONFIRM_CHANNEL_CONTEXT_KEY) === true;\n};\nexports.isConfirmChannelTracing = isConfirmChannelTracing;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsK0JBQStCLEdBQUcsbUNBQW1DLEdBQUcsaUNBQWlDLEdBQUcsc0NBQXNDLEdBQUcseUNBQXlDLEdBQUcseUJBQXlCLEdBQUcsNkJBQTZCLEdBQUcscUNBQXFDLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCO0FBQ2xXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw2SUFBb0I7QUFDMUMsK0JBQStCLG1CQUFPLENBQUMsaU1BQXFDO0FBQzVFLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IscUNBQXFDO0FBQ3JDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNEZBQTRGLFlBQVk7QUFDeEc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BvcGVudGVsZW1ldHJ5K2luc3RydW1lbnRhdGlvbi1hbXFwbGliQDAuNTEuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjAvbm9kZV9tb2R1bGVzL0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbi1hbXFwbGliL2J1aWxkL3NyYy91dGlscy5qcz8wNDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IGV4cG9ydHMudW5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gZXhwb3J0cy5nZXRDb25uZWN0aW9uQXR0cmlidXRlc0Zyb21VcmwgPSBleHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGV4cG9ydHMubm9ybWFsaXplRXhjaGFuZ2UgPSBleHBvcnRzLkNPTk5FQ1RJT05fQVRUUklCVVRFUyA9IGV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBleHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gZXhwb3J0cy5NRVNTQUdFX1NUT1JFRF9TUEFOID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IHNlbWFudGljX2NvbnZlbnRpb25zXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnNcIik7XG5leHBvcnRzLk1FU1NBR0VfU1RPUkVEX1NQQU4gPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5tZXNzYWdlLnN0b3JlZC1zcGFuJyk7XG5leHBvcnRzLkNIQU5ORUxfU1BBTlNfTk9UX0VOREVEID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY2hhbm5lbC5zcGFucy1ub3QtZW5kZWQnKTtcbmV4cG9ydHMuQ0hBTk5FTF9DT05TVU1FX1RJTUVPVVRfVElNRVIgPSBTeW1ib2woJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmNvbnN1bWVyLXRpbWVvdXQtdGltZXInKTtcbmV4cG9ydHMuQ09OTkVDVElPTl9BVFRSSUJVVEVTID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5LmFtcXBsaWIuY29ubmVjdGlvbi5hdHRyaWJ1dGVzJyk7XG5jb25zdCBJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkgPSAoMCwgYXBpXzEuY3JlYXRlQ29udGV4dEtleSkoJ29wZW50ZWxlbWV0cnkuYW1xcGxpYi5jaGFubmVsLmlzLWNvbmZpcm0tY2hhbm5lbCcpO1xuY29uc3Qgbm9ybWFsaXplRXhjaGFuZ2UgPSAoZXhjaGFuZ2VOYW1lKSA9PiBleGNoYW5nZU5hbWUgIT09ICcnID8gZXhjaGFuZ2VOYW1lIDogJzxkZWZhdWx0Pic7XG5leHBvcnRzLm5vcm1hbGl6ZUV4Y2hhbmdlID0gbm9ybWFsaXplRXhjaGFuZ2U7XG5jb25zdCBjZW5zb3JQYXNzd29yZCA9ICh1cmwpID0+IHtcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLzpbXjpAL10qQC8sICc6KioqQCcpO1xufTtcbmNvbnN0IGdldFBvcnQgPSAocG9ydEZyb21VcmwsIHJlc29sdmVkUHJvdG9jb2wpID0+IHtcbiAgICAvLyB3ZSBhcmUgdXNpbmcgdGhlIHJlc29sdmVkIHByb3RvY29sIHdoaWNoIGlzIHVwcGVyIGNhc2VcbiAgICAvLyB0aGlzIGNvZGUgbWltaWMgdGhlIGJlaGF2aW9yIG9mIHRoZSBhbXFwbGliIHdoaWNoIGlzIHVzZWQgdG8gc2V0IGNvbm5lY3Rpb24gcGFyYW1zXG4gICAgcmV0dXJuIHBvcnRGcm9tVXJsIHx8IChyZXNvbHZlZFByb3RvY29sID09PSAnQU1RUCcgPyA1NjcyIDogNTY3MSk7XG59O1xuY29uc3QgZ2V0UHJvdG9jb2wgPSAocHJvdG9jb2xGcm9tVXJsKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRQcm90b2NvbCA9IHByb3RvY29sRnJvbVVybCB8fCAnYW1xcCc7XG4gICAgLy8gdGhlIHN1YnN0cmluZyByZW1vdmVkIHRoZSAnOicgcGFydCBvZiB0aGUgcHJvdG9jb2wgKCdhbXFwOicgLT4gJ2FtcXAnKVxuICAgIGNvbnN0IG5vRW5kaW5nQ29sb24gPSByZXNvbHZlZFByb3RvY29sLmVuZHNXaXRoKCc6JylcbiAgICAgICAgPyByZXNvbHZlZFByb3RvY29sLnN1YnN0cmluZygwLCByZXNvbHZlZFByb3RvY29sLmxlbmd0aCAtIDEpXG4gICAgICAgIDogcmVzb2x2ZWRQcm90b2NvbDtcbiAgICAvLyB1cHBlciBjYXNlcyB0byBtYXRjaCBzcGVjXG4gICAgcmV0dXJuIG5vRW5kaW5nQ29sb24udG9VcHBlckNhc2UoKTtcbn07XG5jb25zdCBnZXRIb3N0bmFtZSA9IChob3N0bmFtZUZyb21VcmwpID0+IHtcbiAgICAvLyBpZiB1c2VyIHN1cHBsaWVzIGVtcHR5IGhvc3RuYW1lLCBpdCBnZXRzIGZvcndhcmRlZCB0byAnbmV0JyBwYWNrYWdlIHdoaWNoIGRlZmF1bHQgaXQgdG8gbG9jYWxob3N0LlxuICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC12MTIueC9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGxpc3RlbmVyXG4gICAgcmV0dXJuIGhvc3RuYW1lRnJvbVVybCB8fCAnbG9jYWxob3N0Jztcbn07XG5jb25zdCBleHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nID0gKHVybCwgYXR0cmlidXRlS2V5LCBhdHRyaWJ1dGVWYWx1ZSwgbmFtZUZvckxvZykgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICByZXR1cm4geyBbYXR0cmlidXRlS2V5XTogYXR0cmlidXRlVmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFwaV8xLmRpYWcuZXJyb3IoYGFtcXBsaWIgaW5zdHJ1bWVudGF0aW9uOiBjb3VsZCBub3QgZXh0cmFjdCBjb25uZWN0aW9uIGF0dHJpYnV0ZSAke25hbWVGb3JMb2d9IGZyb20gdXNlciBzdXBwbGllZCB1cmxgLCB7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufTtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IChjb25uKSA9PiB7XG4gICAgY29uc3QgcHJvZHVjdCA9IGNvbm4uc2VydmVyUHJvcGVydGllcy5wcm9kdWN0Py50b0xvd2VyQ2FzZT8uKCk7XG4gICAgaWYgKHByb2R1Y3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX01FU1NBR0lOR19TWVNURU1dOiBwcm9kdWN0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG5leHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlciA9IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVNlcnZlcjtcbmNvbnN0IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9ICh1cmwpID0+IHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0xfVkVSU0lPTl06ICcwLjkuMScsIC8vIHRoaXMgaXMgdGhlIG9ubHkgcHJvdG9jb2wgc3VwcG9ydGVkIGJ5IHRoZSBpbnN0cnVtZW50ZWQgbGlicmFyeVxuICAgIH07XG4gICAgdXJsID0gdXJsIHx8ICdhbXFwOi8vbG9jYWxob3N0JztcbiAgICBpZiAodHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdE9wdGlvbnMgPSB1cmw7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2woY29ubmVjdE9wdGlvbnM/LnByb3RvY29sKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKHVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gZ2V0SG9zdG5hbWUoY29ubmVjdE9wdGlvbnM/Lmhvc3RuYW1lKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKHVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19ORVRfUEVFUl9OQU1FLCBob3N0bmFtZSwgJ2hvc3RuYW1lJyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwb3J0ID0gZ2V0UG9ydChjb25uZWN0T3B0aW9ucy5wb3J0LCBwcm90b2NvbCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywge1xuICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyh1cmwsIHNlbWFudGljX2NvbnZlbnRpb25zXzEuU0VNQVRUUlNfTkVUX1BFRVJfUE9SVCwgcG9ydCwgJ3BvcnQnKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjZW5zb3JlZFVybCA9IGNlbnNvclBhc3N3b3JkKHVybCk7XG4gICAgICAgIGF0dHJpYnV0ZXNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfVVJMXSA9IGNlbnNvcmVkVXJsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGNlbnNvcmVkVXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wodXJsUGFydHMucHJvdG9jb2wpO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgICAgLi4uZXh0cmFjdENvbm5lY3Rpb25BdHRyaWJ1dGVPckxvZyhjZW5zb3JlZFVybCwgc2VtYW50aWNfY29udmVudGlvbnNfMS5TRU1BVFRSU19NRVNTQUdJTkdfUFJPVE9DT0wsIHByb3RvY29sLCAncHJvdG9jb2wnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSBnZXRIb3N0bmFtZSh1cmxQYXJ0cy5ob3N0bmFtZSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX05BTUUsIGhvc3RuYW1lLCAnaG9zdG5hbWUnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcG9ydCA9IGdldFBvcnQodXJsUGFydHMucG9ydCA/IHBhcnNlSW50KHVybFBhcnRzLnBvcnQpIDogdW5kZWZpbmVkLCBwcm90b2NvbCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgICAgICAgICAuLi5leHRyYWN0Q29ubmVjdGlvbkF0dHJpYnV0ZU9yTG9nKGNlbnNvcmVkVXJsLCBzZW1hbnRpY19jb252ZW50aW9uc18xLlNFTUFUVFJTX05FVF9QRUVSX1BPUlQsIHBvcnQsICdwb3J0JyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhcGlfMS5kaWFnLmVycm9yKCdhbXFwbGliIGluc3RydW1lbnRhdGlvbjogZXJyb3Igd2hpbGUgZXh0cmFjdGluZyBjb25uZWN0aW9uIGRldGFpbHMgZnJvbSBjb25uZWN0aW9uIHVybCcsIHtcbiAgICAgICAgICAgICAgICBjZW5zb3JlZFVybCxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXR0cmlidXRlcztcbn07XG5leHBvcnRzLmdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybCA9IGdldENvbm5lY3Rpb25BdHRyaWJ1dGVzRnJvbVVybDtcbmNvbnN0IG1hcmtDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSAoY29udGV4dCkgPT4ge1xuICAgIHJldHVybiBjb250ZXh0LnNldFZhbHVlKElTX0NPTkZJUk1fQ0hBTk5FTF9DT05URVhUX0tFWSwgdHJ1ZSk7XG59O1xuZXhwb3J0cy5tYXJrQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gbWFya0NvbmZpcm1DaGFubmVsVHJhY2luZztcbmNvbnN0IHVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGNvbnRleHQuZGVsZXRlVmFsdWUoSVNfQ09ORklSTV9DSEFOTkVMX0NPTlRFWFRfS0VZKTtcbn07XG5leHBvcnRzLnVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZyA9IHVubWFya0NvbmZpcm1DaGFubmVsVHJhY2luZztcbmNvbnN0IGlzQ29uZmlybUNoYW5uZWxUcmFjaW5nID0gKGNvbnRleHQpID0+IHtcbiAgICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShJU19DT05GSVJNX0NIQU5ORUxfQ09OVEVYVF9LRVkpID09PSB0cnVlO1xufTtcbmV4cG9ydHMuaXNDb25maXJtQ2hhbm5lbFRyYWNpbmcgPSBpc0NvbmZpcm1DaGFubmVsVHJhY2luZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/utils.js\n");

/***/ }),

/***/ "(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js":
/*!********************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js ***!
  \********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PACKAGE_NAME = exports.PACKAGE_VERSION = void 0;\n// this is autogenerated file, see scripts/version-update.js\nexports.PACKAGE_VERSION = '0.51.0';\nexports.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQSx1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3BlbnRlbGVtZXRyeStpbnN0cnVtZW50YXRpb24tYW1xcGxpYkAwLjUxLjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wL25vZGVfbW9kdWxlcy9Ab3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYi9idWlsZC9zcmMvdmVyc2lvbi5qcz9hYTNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCBUaGUgT3BlblRlbGVtZXRyeSBBdXRob3JzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUEFDS0FHRV9OQU1FID0gZXhwb3J0cy5QQUNLQUdFX1ZFUlNJT04gPSB2b2lkIDA7XG4vLyB0aGlzIGlzIGF1dG9nZW5lcmF0ZWQgZmlsZSwgc2VlIHNjcmlwdHMvdmVyc2lvbi11cGRhdGUuanNcbmV4cG9ydHMuUEFDS0FHRV9WRVJTSU9OID0gJzAuNTEuMCc7XG5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9ICdAb3BlbnRlbGVtZXRyeS9pbnN0cnVtZW50YXRpb24tYW1xcGxpYic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/../../node_modules/.pnpm/@opentelemetry+instrumentation-amqplib@0.51.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation-amqplib/build/src/version.js\n");

/***/ })

};
;